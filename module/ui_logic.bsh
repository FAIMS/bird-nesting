import android.util.Log;

Object dialog;          // Used to help coordinate the display of a "busy..." dialog
String parentTabgroup;  // Used to allow entities to be saved as children
String parentTabgroup__;// Used to allow entities to be saved as children
String redirectTab;     // makes newTab work as expected
String username = "";
String userid   = "";

setFileSyncEnabled(true);
setSyncDelay(5.0f);
setSyncEnabled(true);
setSyncMaxInterval(600.0f);
setSyncMinInterval(5.0f);

/*********************** REGEX-FREE STRING REPLACEMENT ************************/
String replaceFirst(String haystack, String needle, String replacement) {
  i = haystack.indexOf(needle);
  if (i == -1)           return haystack;
  if (needle.equals("")) return haystack;
  pre  = haystack.substring(0, i                                   );
  post = haystack.substring(   i+needle.length(), haystack.length());
  return pre + replacement + post;
}

String replaceFirst(String haystack, String replacement) {
  return replaceFirst(haystack, "%s", replacement);
}

/******************************* LOCALSETTINGS ********************************/
void makeLocalID(){
  fetchOne("CREATE TABLE IF NOT EXISTS localSettings (key text primary key, value text);", null);
  fetchOne("DROP VIEW IF EXISTS parentchild;", null);
  fetchOne("CREATE VIEW parentchild AS "+
           "SELECT parent.uuid as parentuuid, child.uuid as childuuid, parent.participatesverb as parentparticipatesverb, parent.relationshipid, parent.aenttypename as parentaenttypename, child.participatesverb as childparticipatesverb, child.aenttypename as childaenttypename "+
           "  FROM (SELECT uuid, participatesverb, aenttypename, relationshipid"+
           "          FROM latestnondeletedaentreln "+
           "          JOIN relationship USING (relationshipid) "+
           "          JOIN latestnondeletedarchent USING (uuid) "+
           "          JOIN aenttype USING (aenttypeid)) parent "+
           "  JOIN (SELECT uuid, relationshipid, participatesverb, aenttypename "+
           "          FROM latestnondeletedaentreln "+
           "          JOIN relationship USING (relationshipid) "+
           "          JOIN latestnondeletedarchent USING (uuid) "+
           "          JOIN aenttype USING (aenttypeid)) child "+
           "    ON (parent.relationshipid = child.relationshipid AND parent.uuid != child.uuid);", null);
}
makeLocalID();

void insertIntoLocalSettings(String ref) {
  String val = getFieldValue(ref);
  insertIntoLocalSettings(ref, val);
}

void insertIntoLocalSettings(String key, String val) {
  fetchOne("REPLACE INTO localSettings(key, value) VALUES('" + key + "', '" + val + "');");
}

void insertIntoLocalSettings(String key, Integer val) {
  insertIntoLocalSettings(key, Integer.toString(val));
}

void insertIntoLocalSettingsOnChange(String ref) {
  String val = getFieldValue(ref);

  String insertCallback  = "";
  insertCallback += "insertIntoLocalSettings(\"{key}\")";
  insertCallback  = replaceFirst(insertCallback, "{key}", ref);

  addOnEvent(ref, "blur",  insertCallback);
  addOnEvent(ref, "click", insertCallback);
}

void setFieldValueFromLocalSettings(String key, String ref, boolean doOverwrite) {
  String val = getFieldValue(ref);
  if (!isNull(val) && !doOverwrite) {
    return;
  }

  String q = "SELECT value FROM localSettings WHERE key = '" + key + "';";
  fetchOne(q, new FetchCallback() {
    onFetch(result) {
      if (!isNull(result)) {
        setFieldValue(ref, result.get(0));
      }
    }
  });
}

void setFieldValueFromLocalSettings(String ref, boolean doOverwrite) {
  setFieldValueFromLocalSettings(ref, ref, doOverwrite);
}

void setFieldValueFromLocalSettings(String ref) {
  setFieldValueFromLocalSettings(ref, false);
}

void setFieldValueFromLocalSettingsOnShow(String ref, boolean doOverwrite) {
  String cb = "setFieldValueFromLocalSettings(\"%s\", %s)";
  cb = replaceFirst(cb, ref);
  cb = replaceFirst(cb, doOverwrite + "");

  addOnEvent(ref, "show", cb);
}

void setFieldValueFromLocalSettingsOnShow(String ref) {
  boolean doOverwrite = false;
  setFieldValueFromLocalSettingsOnShow(ref, doOverwrite);
}

/* Causes the value of the field given by `ref` to be saved each time it is
 * modified (on blur). The value of the field is restored when the tab group
 * containing the field is displayed.
 *
 * This function depends on `addOnEvent`. Therefore this function must be called
 * after `addOnEvent` is defined, but before `bindOnEvents` is called. This will
 * be so if the call is made in the autogenerator's `logic` tags.
 */
void persistOverSessions(String ref) {
  setFieldValueFromLocalSettingsOnShow(ref);
  insertIntoLocalSettingsOnChange     (ref);
}

/**************************** FIELD COPYING HELPER ****************************/
/* Provides an easy way to copy field values, even between vocabs.            */
/******************************************************************************/
void copyFieldValue(String src, String dst) {
  Boolean doFindVocabId = true;
  copyFieldValue(src, dst, doFindVocabId);
}

/* `src`           The ref of the source field.
 * `dst`           The ref of the destination field.
 * `doFindVocabId` If this is true, and the properties/attributes of `src` and
 *                 `dst` are different, `copyFieldValue` treats `src` and `dst`
 *                 as if they were menus. Therefore, to copy the value seen by
 *                 the user (i.e. the vocabName of `src`), a database query is
 *                 performed. The query determines the which vocabId of `dst`
 *                 will make it display the same vocabName as `src`.
 *
 *                 If `doFindVocabId` is false, the value returned by
 *                 `getFieldValue` is copied, without any database accesses.
 */
void copyFieldValue(String src, String dst, Boolean doFindVocabId) {
  String vocabIdSrc   = getFieldValue(src);
  String vocabNameSrc = getFieldValue(src, true);

  String attrNameSrc = getAttributeName(src);
  String attrNameDst = getAttributeName(dst);

  if (attrNameSrc.equals(attrNameDst) || !doFindVocabId) {
    setFieldValue(dst, vocabIdSrc);
    return;
  }

  String q = "";
  q += "    SELECT vocabid";
  q += "      FROM vocabulary";
  q += " LEFT JOIN attributekey";
  q += "     USING (attributeid)";
  q += "     WHERE attributename = '{attrNameDst}'";
  q += "       AND vocabname     = '{vocabNameSrc}'";
  q  = replaceFirst(q, "{attrNameDst}",  attrNameDst);
  q  = replaceFirst(q, "{vocabNameSrc}", vocabNameSrc);


  FetchCallback populate = new FetchCallback() {
    onFetch(result) {
      if (result == null) {
        // Fall back to dumb field copying
        copyFieldValue(src, dst, false);
      }

      String vocabIdDst = result.get(0);
      setFieldValue(dst, vocabIdDst);
    }
  };

  fetchOne(q, populate);
}

newTab(String tab, Boolean resolveTabGroups) {
  if (!resolveTabGroups) {
    return newTab(tab);
  }

  tab = tab.replaceAll("/$", "");
  tab = tab.replaceAll("^/", "");

  path = tab.split("/");
  switch (path.length) {
    case 0:
      break;
    case 1:
      newTabGroup(path[0]);
      break;
    case 2:
      String tabgroupString = path[0];
      String tabString      = path[0] + "/" + path[1];

      redirectTab = tabString;
      String onShowTabgroup = "if (!isNull(redirectTab)) { newTab(redirectTab); redirectTab = \"\"; }";
      addOnEvent(tabgroupString, "show", onShowTabgroup);

      newTabGroup(tabgroupString);
      newTab(tabString);
      break;
    default:
  }
}

/******************************************************************************/
/*                           DOCUMENT OBJECT MODEL                            */
/******************************************************************************/
String PREVIOUSLY_DISPLAYED_TAB_GROUP = "";
String CURRENTLY_DISPLAYED_TAB_GROUP  = "";

List getTabGroups() {
  List tabGroups = new ArrayList();
  tabGroups.add("Login");
  tabGroups.add("Control");
  tabGroups.add("Box");
  tabGroups.add("Box_Status");
  tabGroups.add("Nest");
  tabGroups.add("Day_of_Lay");
  tabGroups.add("Actual_Day_of_Hatching");
  tabGroups.add("Nest_Measurement");
  tabGroups.add("Egg");
  tabGroups.add("Chick");
  tabGroups.add("Chick_Measurement");

  return tabGroups;
}

void updateDisplayedTabGroup(String tabGroup) {
  PREVIOUSLY_DISPLAYED_TAB_GROUP = CURRENTLY_DISPLAYED_TAB_GROUP;
  CURRENTLY_DISPLAYED_TAB_GROUP  = tabGroup;
}

String getPreviousTabGroup() {
  return getPreviouslyDisplayedTabGroup();
}

String getPreviouslyDisplayedTabGroup() {
  return PREVIOUSLY_DISPLAYED_TAB_GROUP;
}

String getDisplayedTabGroup() {
  return CURRENTLY_DISPLAYED_TAB_GROUP;
}

boolean isDisplayed(String ref) {
  return getDisplayedTabGroup().equals(ref);
}

String getTabGroupRef(String fullRef) {
  Boolean lastPartOnly = false;
  return getTabGroupRef(fullRef, lastPartOnly);
}

String getTabGroupRef(String fullRef, Boolean lastPartOnly) {
  if (isNull(fullRef)) {
    return null;
  }

  String[] parts = fullRef.split("/");

  if (parts.length < 1) return null;
  return parts[0];
}

String getTabRef(String fullRef) {
  Boolean lastPartOnly = false;
  return getTabRef(fullRef, lastPartOnly);
}

String getTabRef(String fullRef, Boolean lastPartOnly) {
  if (isNull(fullRef)) {
    return null;
  }

  String[] parts = fullRef.split("/");

  if (parts.length < 2) return null;
  if (lastPartOnly) return                  parts[1];
  else              return parts[0] + "/" + parts[1];
}

String getLastRefPart(String fullRef) {
  if (isNull(fullRef)) {
    return null;
  }

  String[] parts = fullRef.split("/");
  return parts[parts.length-1];
}

String getGuiElementRef(String fullRef) {
  Boolean lastPartOnly = true;
  return getGuiElementRef(fullRef, lastPartOnly);
}

String getGuiElementRef(String fullRef, Boolean lastPartOnly) {
  if (isNull(fullRef)) {
    return null;
  }

  String[] parts = fullRef.split("/");

  if (parts.length < 3) return null;
  if (lastPartOnly) return parts[2];
  else              return fullRef;
}

String getArch16nKey(String ref) {
  String lastRefPart = getLastRefPart(ref);

  if (isNull(lastRefPart)) return null;
  else                     return "{" + lastRefPart + "}";
}

String guessArch16nVal(String ref) {
  String arch16nKey = getArch16nKey(ref);

  if (isNull(arch16nKey)) return "";
  arch16nKey = arch16nKey.replaceAll("_", " ");
  arch16nKey = arch16nKey.replaceAll("^\\{", "");
  arch16nKey = arch16nKey.replaceAll("\\}$", "");
  return arch16nKey;
}

String getAttributeName(String ref) {
  String guiElementRef = getGuiElementRef(ref);
  if (isNull(guiElementRef)) {
    return null;
  }

  String attributeName = guiElementRef.replaceAll("_", " ");
  return attributeName;
}

String getArchEntType(String ref) {
  String tabGroupRef = getTabGroupRef(ref);
  if (isNull(tabGroupRef)) {
    return null;
  }

  String archEntType = tabGroupRef.replaceAll("_", " ");
  return archEntType;
}

/******************************************************************************/
/*                            BINDING ACCUMULATOR                             */
/*                                                                            */
/* The binding accumulator allows onEvent bindings for the same element to    */
/* accumulate over multiple onEvent calls instead of having later calls       */
/* override earlier ones.                                                     */
/*                                                                            */
/* It also adds support for a several additional events:                      */
/*   - "blur" --- This is merely an interface to make code for adding "blur"  */
/*         events more consistent.                                            */
/*   - "copy" --- Triggered as a record is duplicated, immediately before it  */
/*         is first saved.                                                    */
/*   - "create" --- Triggered after a record is first created.                */
/*   - "fetch" --- Triggered after a record is fetched and displayed in a     */
/*         given tab group.                                                   */
/*   - "focus" --- This is merely an interface to make code for adding        */
/*         "focus" events more consistent.                                    */
/*   - "leave" --- Triggered after a given tab group is navigated away        */
/*         from. Note that this event cannot be triggered when the FAIMS app  */
/*         is exited.                                                         */
/*   - "save" --- Triggered each time a tab group is saved. This includes the */
/*         first time the tab group is saved as well as subsequent            */
/*         onSave(String, Boolean) calls.                                     */
/*                                                                            */
/* A single call to `bindOnEvents` must occur after all the `addOnEvent` and  */
/* `delOnEvents` calls. Calling `bindOnEvents` is what actually establishes   */
/* the bindings once they have been added to the accumulator.                 */
/******************************************************************************/
String SEP = Character.toString ((char) 0); // Beanshell won't let me write "\0"
Map    EVENTS        = new HashMap(); // (ref, event type) -> callback statement
Set    CUSTOM_EVENTS = new HashSet(); // Events not handled by `onEvent`
CUSTOM_EVENTS.add("blur");
CUSTOM_EVENTS.add("copy");
CUSTOM_EVENTS.add("create");
CUSTOM_EVENTS.add("fetch");
CUSTOM_EVENTS.add("focus");
CUSTOM_EVENTS.add("leave");
CUSTOM_EVENTS.add("save");

String getKey(String ref, String event) {
  return ref + SEP + event;
}

/* Returns the set of statements bound to an element at `ref` and occuring on
 * `event`.
 */
ArrayList getStatements(String ref, String event) {
  String    key = getKey(ref, event);
  ArrayList val = (ArrayList) EVENTS.get(key);

  if (val == null) return new ArrayList();
  else             return val;
}

void addStatement(String ref, String event, String statement) {
  // In the case that a statement already exists for a given (`ref`, `event`)
  // pair, writing `val.add(statement);` will be enough to add the extra
  // statement. This is because `getStatements` returns a reference to a list.
  // In the case just described, the list is stored in the `EVENTS` map.
  // However, sometimes `getStatements` returns empty lists which are not stored
  // in that map. In this case, calling `EVENTS.put` is required.

  String    key = getKey(ref, event);
  ArrayList val = getStatements(ref, event);
  val.add(statement);
  EVENTS.put(key, val);
}

String getStatementsString(String ref, String event) {
  ArrayList stmts = getStatements(ref, event);
  String stmtsStr = "";
  for (String s : stmts) {
    stmtsStr += s;
    stmtsStr += "; ";
  }
  return stmtsStr;
}

void delOnEvent(String ref, String event, String statement) {
  while(getStatements(ref, event).remove(statement));
}

void addOnEvent(String ref, String event, String statement) {
  // Calling `delOnEvent()` first ensures statement occurs once in the list, at
  // the end.
  delOnEvent  (ref, event, statement);
  addStatement(ref, event, statement);
}

void bindOnEvent(String ref, String event) {
  String stmtsStr     = getStatementsString(ref, event);
  String focusStmtStr = getStatementsString(ref, "focus");
  String blurStmtStr  = getStatementsString(ref, "blur" );

  if (!CUSTOM_EVENTS.contains(event)) {
    onEvent(ref, event, stmtsStr);
  } else if (event.equals("focus")) {
    onFocus(ref, focusStmtStr, blurStmtStr);
  } else if (event.equals("blur" )) {
    onFocus(ref, focusStmtStr, blurStmtStr);
  } else {
    ; // Other events are implemented using auto-generated callback functions
  }
}

void bindOnEvents() {
  for (String key : EVENTS.keySet()) {
    refevent = key.split(SEP);
    ref   = refevent[0];
    event = refevent[1];
    bindOnEvent(ref, event);
  }
}

void onLeaveTabGroup() {
  onLeaveTabGroup(getPreviouslyDisplayedTabGroup());
}

/* Execute the "leave" event for the tab group at `ref` if a callback for it
 * exists.
 */
void onLeaveTabGroup(String ref) {
  String event    = "leave";
  String stmtsStr = getStatementsString(ref, event);
  execute(stmtsStr);
}

/* Establishes `onEvent` bindings necessary to make the "leave" event work. The
 * "leave" event is really triggered upon "show" of another tab.
 */
for (tg : getTabGroups()) {
  String ref      = tg;
  String event    = "show";
  String callback;

  // Update (previously) displayed tab group
  callback = "updateDisplayedTabGroup(\"%s\")";
  callback = replaceFirst(callback, tg);
  addOnEvent(tg, event, callback);

  // Trigger on leave tab group event
  callback = "onLeaveTabGroup()";
  addOnEvent(tg, event, callback);
}

/******************************************************************************/
/*                           DROPDOWN VALUE GETTER                            */
/*                                                                            */
/* For consistency with `getListItemValue()`.                                 */
/******************************************************************************/
String dropdownItemValue = null;

getDropdownItemValue() {
  return dropdownItemValue;
}

addOnEvent("Control/Active_Boxes/Box_Prefix", "click", "dropdownItemValue = getFieldValue(\"Control/Active_Boxes/Box_Prefix\")");
addOnEvent("Control/Revisit/Days", "click", "dropdownItemValue = getFieldValue(\"Control/Revisit/Days\")");
addOnEvent("Box/Box/Box_Box_Prefix", "click", "dropdownItemValue = getFieldValue(\"Box/Box/Box_Box_Prefix\")");
addOnEvent("Box/Box/Box_Location_Name", "click", "dropdownItemValue = getFieldValue(\"Box/Box/Box_Location_Name\")");
addOnEvent("Box_Status/Box_Status/Box_Status_Box_Prefix", "click", "dropdownItemValue = getFieldValue(\"Box_Status/Box_Status/Box_Status_Box_Prefix\")");
addOnEvent("Box_Status/Box_Status/Box_Status", "click", "dropdownItemValue = getFieldValue(\"Box_Status/Box_Status/Box_Status\")");
addOnEvent("Nest/Nest/Nest_Box_Prefix", "click", "dropdownItemValue = getFieldValue(\"Nest/Nest/Nest_Box_Prefix\")");
addOnEvent("Nest_Measurement/Nest_Measurement/Nest_Status", "click", "dropdownItemValue = getFieldValue(\"Nest_Measurement/Nest_Measurement/Nest_Status\")");
addOnEvent("Egg/Egg/Egg_Box_Prefix", "click", "dropdownItemValue = getFieldValue(\"Egg/Egg/Egg_Box_Prefix\")");
addOnEvent("Chick/Chick/Chick_Box_Prefix", "click", "dropdownItemValue = getFieldValue(\"Chick/Chick/Chick_Box_Prefix\")");
addOnEvent("Chick/Chick/Bird_Species", "click", "dropdownItemValue = getFieldValue(\"Chick/Chick/Bird_Species\")");

/******************************************************************************/
/*                             MENU VALUE GETTER                              */
/*                                                                            */
/* Provides simple ways of getting a menu's vocabname as opposed to the       */
/* default, which is the vocabid.                                             */
/******************************************************************************/
// Map from vocabid to vocabname. Populated by `fetchMenuValues()`.
Map MENU_VALUES = null;

/*
 * Initialises `MENU_VALUES` with the (vocabid -> vocabname) mapping of every
 * menu.
 */
fetchMenuValues() {
  MENU_VALUES = new HashMap();

  String q = "";
  q += " SELECT vocabid, vocabname";
  q += " FROM   vocabulary";

  populateHashMap = new FetchCallback() {
    onFetch(result) {
      for (row : result) {
        vocabId   = row.get(0);
        vocabName = row.get(1);
        MENU_VALUES.put(vocabId, vocabName);
      }
    }
  };

  fetchAll(q, populateHashMap);
}

fetchMenuValues();

/* Returns a menu's vocabname, instead of the (counter-intuitive) vocabid.
 */
getFieldValue(String ref, Boolean doConvertVocabIds) {
  if (!doConvertVocabIds) {
    return getFieldValue(ref);
  }

  String val       = getFieldValue(ref);
  String vocabName = MENU_VALUES.get(val);

  if (val       == null) return "";
  if (vocabName == null) return "";
  return vocabName;
}

/* Shorthand for writing getFieldValue(ref, true). This function's use is
 * discouraged in favour of writing `getFieldValue(ref, true)`.
 */
getMenuValue(String ref) {
  return getFieldValue(ref, true);
}

/******************************************************************************/
/*                                 ACTION BAR                                 */
/******************************************************************************/
addActionBarItem("clean_synced_files", new ActionButtonCallback() {
  actionOnLabel() {
    "{Clean_Synced_Files}";
  }
  actionOn() {
    cleanSyncedFiles();
  }
});

addActionBarItem("sync", new ToggleActionButtonCallback() {
  actionOnLabel() {
    "{Disable_Sync}";
  }
  actionOn() {
    setSyncEnabled(false);
    setFileSyncEnabled(false);
    showToast("{Sync_Disabled}");
  }
  isActionOff() {
    isSyncEnabled();
  }
  actionOffLabel() {
    "{Enable_Sync}";
  }
  actionOff() {
    setSyncEnabled(true);
    setFileSyncEnabled(true);
    showToast("{Sync_Enabled}");
  }
});

addActionBarItem("internal_gps", new ToggleActionButtonCallback() {
  actionOnLabel() {
    "{Disable_Internal_GPS}";
  }
  actionOn() {
    stopGPS();
    showToast("{Internal_GPS_Disabled}");
    updateGPSDiagnostics();
  }
  isActionOff() {
    isInternalGPSOn();
  }
  actionOffLabel() {
    "{Enable_Internal_GPS}";
  }
  actionOff() {
    if(isExternalGPSOn()) {
      stopGPS();
    }
    startInternalGPS();
    showToast("{Internal_GPS_Enabled}");
    updateGPSDiagnostics();
  }
});

addActionBarItem("external_gps", new ToggleActionButtonCallback() {
  actionOnLabel() {
    "{Disable_External_GPS}";
  }
  actionOn() {
    stopGPS();
    if (isBluetoothConnected()) {
      showToast("{External_GPS_Disabled}");
    } else {
      showToast("{Please_Enable_Bluetooth}");
    }
    updateGPSDiagnostics();
  }
  isActionOff() {
    isExternalGPSOn();
  }
  actionOffLabel() {
    "{Enable_External_GPS}";
  }
  actionOff() {
    if(isInternalGPSOn()) {
      stopGPS();
    }
    startExternalGPS();
    if(isBluetoothConnected()) {
      showToast("{External_GPS_Enabled}");
    } else {
      showToast("{Please_Enable_Bluetooth}");
      this.actionOn();
    }
    updateGPSDiagnostics();
  }
});


/******************************************************************************/
/*                                    GPS                                     */
/******************************************************************************/

updateGPSDiagnostics() {
  String diagnosticsRef = "";
  if (diagnosticsRef.equals("")) {
    return;
  }

  String status         = "";
  String previousStatus = getFieldValue(diagnosticsRef);
  String notInitialised = "{GPS_is_not_initialised}";

  // Check if GPS is initialised or was previously initialised.
  if (!isExternalGPSOn() && !isInternalGPSOn()) {
    if (!isNull(previousStatus) && !previousStatus.equals(notInitialised)) { // previous gps status is some last valid coordinate.
      // This is hackish. Arch16n substitution happens only at display-time, but the following if clause requires substitution to have happened at run-time
      String error = "";
      error = "{GPS_is_no_longer_initialised}. {Previous_status}:";
      setFieldValue(diagnosticsRef, error);   // Arch16n entry is substituted after this
      error = getFieldValue(diagnosticsRef);

      // check that error message wasn't previously appended to the previous status message.
      if (previousStatus.length()    >= error.length() &&
          previousStatus.subSequence(0, error.length()).equals(error)) {
        status = previousStatus;
      } else {
        status = error + "\n" + previousStatus;
      }
    } else {
      status = notInitialised;
    }
  } else {
    status += "{Internal_GPS}: ";
    if (isInternalGPSOn())
    {
      status += "{on}";
    } else {
      status += "{off}";
    }
    status += "\nExternal GPS: ";
    if (isExternalGPSOn())
    {
      if (isBluetoothConnected()) {
        status += "{on_and_bluetooth_connected}";
      } else {
        status += "{on_and_bluetooth_disconnected}";
      }
    } else {
      status += "{off}";
    }
    Object position = getGPSPosition();
    if (position != null) {
      Object projPosition = getGPSPositionProjected();
      status += "\n{Latitude}: " + position.getLatitude();
      status += "   {Longitude}: " + position.getLongitude();
      status += "\n{Northing}: " + projPosition.getLatitude();
      status += "   {Easting}: " + projPosition.getLongitude();
      status += "\n{Accuracy}: " + getGPSEstimatedAccuracy();
    } else {
      status += "\n{Position}: {no_GPS_position_could_be_found}";
    }
  }
  setFieldValue(diagnosticsRef, status);
}

/******************************************************************************/
/*                                 USER LOGIN                                 */
/******************************************************************************/

String userMenuPath = "Login/Login/User";

void populateListForUsers(){
  String getNonDeletedUsersQuery = "SELECT userid, fname || ' ' || lname "+
                                   "  FROM user "+
                                   " WHERE userdeleted is null;";

  fetchAll(getNonDeletedUsersQuery, new FetchCallback() {
    onFetch(result) {
      populateList(userMenuPath, result);
    }
  });
}

void selectUser() {
  String userVocabId  = getListItemValue();
  String userQ        = "SELECT userid,fname,lname,email FROM user " +
                        "WHERE  userid='" + userVocabId + "';";
  FetchCallback callback = new FetchCallback() {
    onFetch(result) {
      user = new User(
            result.get(0),
            result.get(1),
            result.get(2),
            result.get(3)
      );
      setUser(user);
      username = result.get(1) + " " + result.get(2);
      userid   = result.get(0);
    }
  };

  fetchOne(userQ, callback);
}

addOnEvent(userMenuPath, "show",  "populateListForUsers()");
addOnEvent(userMenuPath, "click", "selectUser()");


/******************************************************************************/
/*                              MENU POPULATION                               */
/******************************************************************************/
/** Fetches the contents of a specifed vocabulary and stores it in the given list. **/
void fetchVocab(String vocabName, List storageList) {
  fetchVocab(vocabName, storageList, null);
}
void fetchVocab(String vocabName, List storageList, String callbackFunction) {
  fetchAll("select vocabid, vocabname from vocabulary left join attributekey using (attributeid) where attributename = '" + vocabName + "';", new FetchCallback() {
    onFetch(result) {
      storageList.addAll(result);
      Log.d("fetchVocab()", "Fetched vocabulary \"" + vocabname + "\" contents: " + result.toString());
      if (callbackFunction != null && !isNull(callbackFunction)) {
        execute(callbackFunction);
      }
    }
  });
}

/** Wrapper for to make a vocab without an exlusion list **/
void makeVocab(String type, String path, String attrib) {
  makeVocab(type, path, attrib, null);
}

/** Vocab Population **/
/* Populates the path specified vocabulary from the database based on the given attribute name, where type 
is the type of the vocab to populate (PictureGallery, HierarchicalPictureGallery, CheckBoxGroup, DropDown, HierarchicalDropDown, RadioGroup or List). */
void makeVocab(String type, String path, String attrib, List vocabExclusions) {
    makeVocab(type, path, attrib, vocabExclusions, null);
}

/* Populates the path specified vocabulary from the database based on the given attribute name, where type 
is the type of the vocab to populate (PictureGallery, HierarchicalPictureGallery, CheckBoxGroup, DropDown, HierarchicalDropDown, RadioGroup or List). */
void makeVocab(String type, String path, String attrib, List vocabExclusions, String callbackFunction){
  if (isNull(type) || isNull(path) || isNull(attrib)) {
    Log.e("makeVocab()", "Can't make populate a vocab when the given type, path or attribute is Null");
    return;
  }

  if (type.equals("PictureGallery")) {
    String pictureGalleryQuery = "SELECT vocabid, vocabname, pictureurl "+
                                 "  FROM vocabulary "+
                                 "  LEFT OUTER JOIN attributekey USING (attributeid) "+
                                 " WHERE attributename = '" + attrib + "' "+
                                 " ORDER BY  vocabcountorder;";
    fetchAll(pictureGalleryQuery, new FetchCallback() {
      onFetch(pictures) {
        populatePictureGallery(path, pictures);
        if (callbackFunction != null && !isNull(callbackFunction)) {
          execute(callbackFunction);
        }
      }
    });
    return;
  }

  if (type.equals("HierarchicalPictureGallery")) {
    populateHierarchicalPictureGallery(path, attrib);
    if (callbackFunction != null && !isNull(callbackFunction)) {
      execute(callbackFunction);
    }
    return;
  }

  if (type.equals("HierarchicalDropDown")) {
    // populateHierarchicalDropDown(path, attrib);
    populateHierarchicalDropDown(path, attrib, true);
    if (callbackFunction != null && !isNull(callbackFunction)) {
      execute(callbackFunction);
    }
    return;
  }

  String getAttributeVocabQuery = "SELECT vocabid, vocabname "+
                                  "  FROM vocabulary "+
                                  "  JOIN attributekey USING (attributeid) "+
                                  " WHERE attributename = '" + attrib + "' "+
                                  " ORDER BY vocabcountorder;";
  fetchAll(getAttributeVocabQuery,
    new FetchCallback() {
      onFetch(result) {
        // print("makeVocab() result: " + result);
        if (result!=null && result.size()>0 && vocabExclusions!=null && vocabExclusions.size()>0) {
          List filteredVocab = new ArrayList();
          for(item : result) {
            if (vocabExclusions.contains(item.get(1))) {
              Log.d("makeVocab()", "removing vocab exclusion: " + item.get(1));
            } else {
              filteredVocab.add(item);
            }
          }
          result=filteredVocab;
        }
        Boolean hasNull =
                vocabExclusions == null
            || !vocabExclusions.contains("")
            && !vocabExclusions.contains(null);
        // print("makeVocab() filtered result: " + result);
        if(type.equals("CheckBoxGroup")) {
          populateCheckBoxGroup(path, result);
        } else if(type.equals("DropDown")) {
          // populateDropDown(path, result);
          populateDropDown(path, result, hasNull);
        } else if(type.equals("RadioGroup")) {
          populateRadioGroup(path, result);
        } else if(type.equals("List")) {
          populateList(path, result);
        }
        if (callbackFunction != null && !isNull(callbackFunction)) {
          execute(callbackFunction);
        }
      }
    });
}
makeVocab("DropDown", "Box/Box/Box_Box_Prefix", "Box Box Prefix");
makeVocab("DropDown", "Box/Box/Box_Location_Name", "Box Location Name");
makeVocab("DropDown", "Box_Status/Box_Status/Box_Status_Box_Prefix", "Box Status Box Prefix");
makeVocab("DropDown", "Box_Status/Box_Status/Box_Status", "Box Status");
makeVocab("DropDown", "Nest/Nest/Nest_Box_Prefix", "Nest Box Prefix");
makeVocab("DropDown", "Nest_Measurement/Nest_Measurement/Nest_Status", "Nest Status");
makeVocab("DropDown", "Egg/Egg/Egg_Box_Prefix", "Egg Box Prefix");
makeVocab("DropDown", "Chick/Chick/Chick_Box_Prefix", "Chick Box Prefix");
makeVocab("DropDown", "Chick/Chick/Bird_Species", "Bird Species");
makeVocab("RadioGroup", "Chick_Measurement/Chick_Measurement/Chick_Alive", "Chick Alive");


/******************************************************************************/
/*                                 VALIDATION                                 */
/******************************************************************************/
/* `ref`  is a reference/path to a field
 * `name` is a human-readable name for that field
 * `cond` is a String containing a boolean expression that evaluates to true if
 *        and only if the the field pair returned by this function should be
 *        validated.
 *
 *  Returns a field pair (really just an ArrayList).
 */
fieldPair(String ref, String name, String cond) {
  List fp = new ArrayList();
  fp.add(ref);
  fp.add(name);
  fp.add(cond);
  return fp;
}

fieldPair(String ref, String name) {
  String t = "true";
  return fieldPair(ref, name, t);
}

/* Returns true if field specified by `ref` is valid. False otherwise.
 */
isValidField(String ref) {
  return !isNull(getFieldValue(ref));
}
/* `format` can either be HTML or PLAINTEXT
 */
validateFields(List fields, String format) {
  Integer numInvalid = 0;

  /* Build validation message string (and count how many invalid fields exist) */
  String out = "Please fill out the following fields:\n";
  for(f : fields) {
    String ref  = f.get(0); // Reference to field
    String name = f.get(1); // Human-readable name
    String cond = f.get(2); // Validation condition

    // Only validate a field whose validation condition evaluates to `true`
    Boolean doValidateField = (Boolean) eval(cond);
    if (!doValidateField)
      continue;

    // Add any invalid fields to the output and tally them
    if (!isValidField(ref)) {
      out += "- " + name + "\n";
      numInvalid++;
    }
  }
  // All the fields are valid; just overwrite `out` with a cheery message
  if (numInvalid == 0)
    out = "All fields contain valid data!";

  /* Format the output as dictated by `format` */
  if (format == "HTML") {
    out = out.replace("\n", "<br>");
  } else if (format == "PLAINTEXT") {
    ;
  }

  return out;
}



/******************************************************************************/
/*                                 AUTOSAVING                                 */
/******************************************************************************/
Map tabgroupToUuid = Collections.synchronizedMap(new HashMap());

String getUuid(String tabgroup) {
  return tabgroupToUuid.get(tabgroup);
}

void setUuid(String tabgroup, String uuid) {
  tabgroupToUuid.put(tabgroup, uuid);
}

void saveTabGroup(String tabgroup) {
  saveTabGroup(tabgroup, "");
}

void saveTabGroup(String tabgroup, String callback) {
  Boolean enableAutosave      = true;
  String  id                  = getUuid(tabgroup);
  List    geometry            = null;
  List    attributes          = null;
  String  parentTabgroup_     = parentTabgroup;
  String  parentTabgroupUuid_ = getUuid(parentTabgroup_);
  Boolean userWasSet          = !username.equals("");

  String repopulateEntityList;
  repopulateEntityList = "populateEntityListsInTabGroup(\"{tabGroup}\")";
  repopulateEntityList = replaceFirst(repopulateEntityList, "{tabGroup}", parentTabgroup__);

  callback = repopulateEntityList + ";" + callback;

  parentTabgroup = null;

  SaveCallback saveCallback  = new SaveCallback() {
    onSave(uuid, newRecord) {
      setUuid(tabgroup, uuid);
      // Make a child-parent relationship if need be.
      if (
          newRecord &&
          !isNull(parentTabgroup_) &&
          !isNull(parentTabgroupUuid_)
      ) {
        String rel = "";
        rel += parentTabgroup_.replaceAll("_", " ");
        rel += " - ";
        rel += tabgroup.replaceAll("_", " ");
        saveEntitiesToHierRel(
          rel,
          parentTabgroupUuid_,
          uuid,
          "Parent Of",
          "Child Of",
          callback
        );
      } else {
        execute(callback);
      }

      // This fixes an interesting bug. Without this, if a user was not set
      // (by calling `setUser`) at the time `saveTabGroup` was first called, but
      // set by the time `onSave` was called, the tab group is saved correctly
      // the first time only.
      //
      // Adding this allows subsequent saves to succeed. Presumably it plays
      // some role in helping FAIMS associate the correct user with a record.
      if (!userWasSet) {
        saveTabGroup(tabgroup, callback);
      }

    }
    onError(message) {
      showToast(message);
    }
  };

  saveTabGroup(tabgroup, id, geometry, attributes, saveCallback, enableAutosave);
}

void setToTimestampNow(String ref) {
  String now = getTimestampNow();
  setFieldValue(ref, now);
}

String getTimestampNow() {
  String fmt = "yyyy-MM-dd HH:mm:ssZ";
  return getTimestampNow(fmt);
}

String getTimestampNow(String fmt) {
  date    = new Date();
  dateFmt = new java.text.SimpleDateFormat(fmt);
  dateStr = dateFmt.format(date);

  // Insert colon into timezone (e.g. +1000 -> +10:00)
  String left; String right;

  left    = dateStr.substring(0, dateStr.length() - 2);
  right   = dateStr.substring(   dateStr.length() - 2);
  dateStr = left + ":" + right;

  return dateStr;
}

void populateAuthorAndTimestamp(String tabgroup) {
  Map tabgroupToAuthor    = new HashMap();
  Map tabgroupToTimestamp = new HashMap();
  tabgroupToTimestamp.put("Box_Status", "Box_Status/Box_Status/timestamp");
  tabgroupToTimestamp.put("Nest", "Nest/Nest/timestamp");
  tabgroupToTimestamp.put("Nest_Measurement", "Nest_Measurement/Nest_Measurement/timestamp");
  tabgroupToTimestamp.put("Egg", "Egg/Egg/timestamp");
  tabgroupToTimestamp.put("Chick", "Chick/Chick/timestamp");
  tabgroupToTimestamp.put("Chick_Measurement", "Chick_Measurement/Chick_Measurement/timestamp");

  String authorPath    = tabgroupToAuthor.get(tabgroup);
  String timestampPath = tabgroupToTimestamp.get(tabgroup);

  String authorVal    = username;
  String timestampVal = getTimestampNow();

  if (!isNull(authorPath))    setFieldValue(authorPath,    authorVal);
  if (!isNull(timestampPath)) setFieldValue(timestampPath, timestampVal);
}

void onShowBox () {
  // TODO: Add some things which should happen when this tabgroup is shown
  saveTabGroup("Box", "onSaveBox__()");
}
void onShowBoxStatus () {
  // TODO: Add some things which should happen when this tabgroup is shown
  saveTabGroup("Box_Status", "onSaveBoxStatus__()");
}
void onShowNest () {
  // TODO: Add some things which should happen when this tabgroup is shown
  saveTabGroup("Nest", "onSaveNest__()");
}
void onShowNestMeasurement () {
  // TODO: Add some things which should happen when this tabgroup is shown
  saveTabGroup("Nest_Measurement", "onSaveNestMeasurement__()");
}
void onShowEgg () {
  // TODO: Add some things which should happen when this tabgroup is shown
  saveTabGroup("Egg", "onSaveEgg__()");
}
void onShowChick () {
  // TODO: Add some things which should happen when this tabgroup is shown
  saveTabGroup("Chick", "onSaveChick__()");
}
void onShowChickMeasurement () {
  // TODO: Add some things which should happen when this tabgroup is shown
  saveTabGroup("Chick_Measurement", "onSaveChickMeasurement__()");
}

addOnEvent("Box", "show", "onShowBox()");
addOnEvent("Box_Status", "show", "onShowBoxStatus()");
addOnEvent("Nest", "show", "onShowNest()");
addOnEvent("Nest_Measurement", "show", "onShowNestMeasurement()");
addOnEvent("Egg", "show", "onShowEgg()");
addOnEvent("Chick", "show", "onShowChick()");
addOnEvent("Chick_Measurement", "show", "onShowChickMeasurement()");

void onClickLoginUser () {
  // TODO: Add some things which should happen when this element is clicked
  newTab("Control", true);
}
void onClickControlAddNewBox () {
  // TODO: Add some things which should happen when this element is clicked
  parentTabgroup__ = "Control";
  newBox();
}
void onClickNestSetDayofLay () {
  // TODO: Add some things which should happen when this element is clicked
  newTab("Day_of_Lay", true);
}
void onClickNestSetActualDayofHatching () {
  // TODO: Add some things which should happen when this element is clicked
  newTab("Actual_Day_of_Hatching", true);
}
void onClickBoxAddBoxStatus () {
  // TODO: Add some things which should happen when this element is clicked
  String tabgroup = "Box";
  if (isNull(getUuid(tabgroup))){
    showToast("{You_must_save_this_tabgroup_first}");
    return;
  }
  parentTabgroup   = tabgroup;
  parentTabgroup__ = tabgroup;
  newBoxStatus();
}
void onClickBoxAddNewNest () {
  // TODO: Add some things which should happen when this element is clicked
  String tabgroup = "Box";
  if (isNull(getUuid(tabgroup))){
    showToast("{You_must_save_this_tabgroup_first}");
    return;
  }
  parentTabgroup   = tabgroup;
  parentTabgroup__ = tabgroup;
  newNest();
}
void onClickNestAddNestMeasurement () {
  // TODO: Add some things which should happen when this element is clicked
  String tabgroup = "Nest";
  if (isNull(getUuid(tabgroup))){
    showToast("{You_must_save_this_tabgroup_first}");
    return;
  }
  parentTabgroup   = tabgroup;
  parentTabgroup__ = tabgroup;
  newNestMeasurement();
}
void onClickNestAddNewEgg () {
  // TODO: Add some things which should happen when this element is clicked
  String tabgroup = "Nest";
  if (isNull(getUuid(tabgroup))){
    showToast("{You_must_save_this_tabgroup_first}");
    return;
  }
  parentTabgroup   = tabgroup;
  parentTabgroup__ = tabgroup;
  newEgg();
}
void onClickNestAddNewChick () {
  // TODO: Add some things which should happen when this element is clicked
  String tabgroup = "Nest";
  if (isNull(getUuid(tabgroup))){
    showToast("{You_must_save_this_tabgroup_first}");
    return;
  }
  parentTabgroup   = tabgroup;
  parentTabgroup__ = tabgroup;
  newChick();
}
void onClickChickAddChickMeasurement () {
  // TODO: Add some things which should happen when this element is clicked
  String tabgroup = "Chick";
  if (isNull(getUuid(tabgroup))){
    showToast("{You_must_save_this_tabgroup_first}");
    return;
  }
  parentTabgroup   = tabgroup;
  parentTabgroup__ = tabgroup;
  newChickMeasurement();
}

addOnEvent("Login/Login/User", "click", "onClickLoginUser()");
addOnEvent("Control/Control/Add_New_Box", "click", "onClickControlAddNewBox()");
addOnEvent("Box/Box/Add_Box_Status", "click", "onClickBoxAddBoxStatus()");
addOnEvent("Box/Box/Add_New_Nest", "click", "onClickBoxAddNewNest()");
addOnEvent("Nest/Nest/Set_Day_of_Lay", "click", "onClickNestSetDayofLay()");
addOnEvent("Nest/Nest/Set_Actual_Day_of_Hatching", "click", "onClickNestSetActualDayofHatching()");
addOnEvent("Nest/Nest/Add_Nest_Measurement", "click", "onClickNestAddNestMeasurement()");
addOnEvent("Nest/Egg_Chick/Add_New_Egg", "click", "onClickNestAddNewEgg()");
addOnEvent("Nest/Egg_Chick/Add_New_Chick", "click", "onClickNestAddNewChick()");
addOnEvent("Chick/Chick/Add_Chick_Measurement", "click", "onClickChickAddChickMeasurement()");


/******************************************************************************/
/*                   AUDIO, CAMERA, FILE AND VIDEO BINDINGS                   */
/******************************************************************************/
addOnEvent("Box/Box/Button_Take_Photo", "click", "attachPictureTo(\"Box/Box/Take_Photo\")");
addOnEvent("Chick_Measurement/Chick_Measurement/Button_Picture", "click", "attachPictureTo(\"Chick_Measurement/Chick_Measurement/Picture\")");

/******************************************************************************/
/*                             NAVIGATION DRAWER                              */
/******************************************************************************/
removeNavigationButtons() {
  removeNavigationButton("new");
  removeNavigationButton("duplicate");
  removeNavigationButton("delete");
  removeNavigationButton("validate");
}

addNavigationButtons(String tabgroup) {
  removeNavigationButtons();
  List tabgroupsToValidate = new ArrayList();

  addNavigationButton("new", new ActionButtonCallback() {
    actionOnLabel() {
      "{New}";
    }
    actionOn() {
      if(isNull(getUuid(tabgroup))) {
          newRecord(tabgroup, true);
          showToast("{New_record_created}");
      } else {
          showAlert("{Warning}", "{Any_unsaved_changes_will_be_lost}", "newRecord(\""+tabgroup+"\", true)", "");
      }
    }
  }, "success");  addNavigationButton("delete", new ActionButtonCallback() {
    actionOnLabel() {
      "{Delete}";
    }
    actionOn() {
      deleteRecord(tabgroup);
    }
  }, "danger");
  if (tabgroupsToValidate.contains(tabgroup)) {
    addNavigationButton("validate", new ActionButtonCallback() {
      actionOnLabel() {
        "{Validate}";
      }
      actionOn() {
        String validationFunction = "validate" + tabgroup.replaceAll("_", "") + "()";
        eval(validationFunction);
      }
    }, "default");
  }
}

/******************************************************************************/
/*        ENTITY AND RELATIONSHIP SAVING AND LOADING HELPER FUNCTIONS         */
/******************************************************************************/
/** Saves two entity id's as a relation. **/
void saveEntitiesToRel(String type, String entity1, String entity2) {
  String callback = null;
  saveEntitiesToRel(type, entity1, entity2, callback);
}

/** Saves two entity id's as a relation with some callback executed. **/
void saveEntitiesToRel(String type, String entity1, String entity2, String callback) {
  String e1verb = null;
  String e2verb = null;
  saveEntitiesToHierRel(type, entity1, entity2, e1verb, e2verb, callback);
}

/** Saves two entity id's as a hierachical relation with some callback executed. **/
void saveEntitiesToHierRel(String type, String entity1, String entity2, String e1verb, String e2verb, String callback) {
  if (isNull(entity1) || isNull(entity2)) return;
  saveRel(null, type, null, null, new SaveCallback() {
    onSave(rel_id, newRecord) {
      addReln(entity1, rel_id, e1verb);
      addReln(entity2, rel_id, e2verb);
      if(!isNull(callback)) {
         execute(callback);
      }
    }
    onError(message) {
      Log.e("saveEntitiesToHierRel", message);
      showToast(message);
    }
  });
}

// Makes a new record of the given tabgroup
void newRecord(String tabgroup) {
  boolean doUpdateRelVars = false;
  newRecord(tabgroup, doUpdateRelVars);
}

void newRecord(String tabgroup, boolean doUpdateRelVars) {
  if (doUpdateRelVars) {
    String uuidOld = getUuid(getDisplayedTabGroup());
    String q       = getDuplicateRelnQuery(uuidOld); // We're not duplicating
                                                     // anything, just getting
                                                     // the parent's UUID.

    cancelTabGroup(tabgroup, false);

    FetchCallback updateRelVars = new FetchCallback() {
      onFetch(result) {
        if (result != null && result.size() >= 1) {
          parentTabgroup   = result.get(0).get(4);
          parentTabgroup   = parentTabgroup.replaceAll(" ", "_");
          parentTabgroup__ = parentTabgroup;
        }

        newRecord(tabgroup, false);
      }
    };
    fetchAll(q, updateRelVars);
    return;
  }

  String newTabGroupFunction = "new" + tabgroup.replaceAll("_", "") + "()"; // Typical value: "newTabgroup()"
  eval(newTabGroupFunction);

  Log.d("newRecord", tabgroup);
}

// Deletes the current record of the given tabgroup
void deleteRecord(String tabgroup) {
  String deleteTabGroupFunction = "delete" + tabgroup.replaceAll("_", "") + "()"; // Typical value: "deleteTabgroup()"
  eval(deleteTabGroupFunction);

  Log.d("deleteRecord", tabgroup);
}

// Duplicates the current record of the given tabgroup
void duplicateRecord(String tabgroup) {
  dialog = showBusy("Duplicating", "Please wait...");

  String duplicateTabGroupFunction = "duplicate" + tabgroup.replaceAll("_", "") + "()"; // Typical value: "duplicateTabgroup()"
  eval(duplicateTabGroupFunction);

  Log.d("duplicateRecord", tabgroup);
}

// generic fetch saved attributes query
String getDuplicateAttributeQuery(String originalRecordID, String attributesToDupe) {
  if (attributesToDupe.equals("")) {
    attributesToDupe = "''";
  }
  String duplicateQuery = "SELECT attributename, freetext, vocabid, measure, certainty " +
                          "  FROM latestnondeletedaentvalue JOIN attributekey USING (attributeid) " +
                          " WHERE attributename IN ('', "+attributesToDupe+") " +
                          "   AND uuid = '"+originalRecordID+"'; ";
  return duplicateQuery;
}

String getDuplicateRelnQuery(String originalRecordID) {
  String dupeRelnQuery = "SELECT relntypename, parentparticipatesverb, childparticipatesverb, parentuuid, parentaenttypename, childaenttypename"+
                         "  FROM parentchild join relationship using (relationshipid) "+
                         "  JOIN relntype using (relntypeid) "+
                         " WHERE childuuid = '"+originalRecordID+"' " +
                         "   AND parentparticipatesverb = 'Parent Of' ";
  return dupeRelnQuery;
}

void makeDuplicateRelationships(fetchedAttributes, String newUuid){
  Log.e("Module", "makeDuplicateRelationships");
  for (savedAttribute : fetchedAttributes){
    String relntypename           = savedAttribute.get(0);
    String parentparticipatesverb = savedAttribute.get(1);
    String childparticipatesverb  = savedAttribute.get(2);
    String parentUuid             = savedAttribute.get(3);
    saveEntitiesToHierRel(relntypename, parentUuid, newUuid, parentparticipatesverb, childparticipatesverb, null);
  }
}

// generic get extra attributes
List getExtraAttributes(fetchedAttributes) {
  List extraAttributes = createAttributeList();
  Log.d("Module", "Duplicating fetched attributes: " + fetchedAttributes.toString());
  for (savedAttribute : fetchedAttributes) {
    extraAttributes.add(
      createEntityAttribute(
        savedAttribute.get(0),
        savedAttribute.get(1),
        savedAttribute.get(2),
        savedAttribute.get(3),
        savedAttribute.get(4)
      )
    );
  }
  return extraAttributes;
}

void loadEntity() {
  loadEntity(false);
}
void loadEntity(Boolean isDropdown) {
  if (isDropdown) {
    loadEntityFrom(getDropdownItemValue());
  } else {
    loadEntityFrom(getListItemValue());
  }
}

void loadEntityFrom(String entityID) {
  if (isNull(entityID)) {
    Log.e("Module", "Cannot load an entity with a null ID.");
    return;
  }

  String getEntTypeNameQ = "SELECT aenttypename " +
                           "  FROM latestnondeletedarchent " +
                           "  JOIN aenttype " +
                           " USING (aenttypeid) " +
                           " WHERE uuid = '" + entityID + "'";
  fetchAll(getEntTypeNameQ, new FetchCallback() {
    onFetch(result) {
      String archEntName = result.get(0).get(0);
      String loadFunction = "load" + archEntName.replaceAll(" ", "") + "From(entityID)"; // Typical value: loadContextFrom(entityID)
      eval(loadFunction);
    }
  });
}

void newBox(){
  String tabgroup = "Box";


  setUuid(tabgroup, null);
  newTabGroup(tabgroup);
  populateAuthorAndTimestamp(tabgroup);
  populateEntityListsInTabGroup(tabgroup);
  onCreateBox__();

  // WARNING: The default behaviour of calling `onCreateBox()` upon entity creation is deprecated in this version of FAIMS Tools. If you never implemented this function, this warning can safely be ignored.
  inheritBoxFields();
}


void onCreateBox__(){
  String ref      = "Box";
  String event    = "create";
  String stmtsStr = getStatementsString(ref, event);
  execute(stmtsStr);
}



// Triggered after an existing record is loaded.
void onFetchBox__(){
  String ref      = "Box";
  String event    = "fetch";
  String stmtsStr = getStatementsString(ref, event);
  execute(stmtsStr);
}



// Triggered after an existing record is saved.
void onSaveBox__(){
  String ref      = "Box";
  String event    = "save";
  String stmtsStr = getStatementsString(ref, event);
  execute(stmtsStr);
}



// Triggered as a record is duplicated but before it's saved.
void onCopyBox__(){
  String ref      = "Box";
  String event    = "copy";
  String stmtsStr = getStatementsString(ref, event);
  execute(stmtsStr);
}

void duplicateBox(){
  String tabgroup = "Box";
  String uuidOld = getUuid(tabgroup);

  disableAutoSave(tabgroup);

  clearGpsInTabGroup(tabgroup);

  populateCameraPictureGallery("Box/Box/Take_Photo", new ArrayList());

  onCopyBox__();

  saveCallback = new SaveCallback() {
    onSave(uuid, newRecord) {
      setUuid(tabgroup, uuid);
      populateAuthorAndTimestamp(tabgroup);

      Boolean enable_autosave = true;

      fetchAll(getDuplicateRelnQuery(uuidOld), new FetchCallback(){
        onFetch(result) {
          Log.e("Module", result.toString());

          if (result != null && result.size() >= 1) {
            parentTabgroup__ = result.get(0).get(4);
            parentTabgroup__ = parentTabgroup__.replaceAll(" ", "_");
          }

          makeDuplicateRelationships(result, getUuid(tabgroup));

          showToast("{Duplicated_record}");
          dialog.dismiss();
        }
      });

      saveTabGroup(tabgroup);
    }
  };

  String extraDupeAttributes = "";
  fetchAll(getDuplicateAttributeQuery(getUuid(tabgroup), extraDupeAttributes), new FetchCallback(){
    onFetch(result) {
      excludeAttributes = new ArrayList();
      excludeAttributes.add("Take Photo");

      duplicateTabGroup(tabgroup, null, getExtraAttributes(result), excludeAttributes, saveCallback);
    }
  });
}

void deleteBox(){
  String tabgroup = "Box";

  if (isNull(getUuid(tabgroup))) {
    cancelTabGroup(tabgroup, true);
  } else {
    showAlert("{Confirm_Deletion}", "{Press_OK_to_Delete_this_Record}", "reallyDeleteBox()", "doNotDelete()");
  }
}

void reallyDeleteBox(){
  String tabgroup = "Box";
  deleteArchEnt(getUuid(tabgroup));
  cancelTabGroup(tabgroup, false);
}

void newBoxStatus(){
  String tabgroup = "Box_Status";


  setUuid(tabgroup, null);
  newTabGroup(tabgroup);
  populateAuthorAndTimestamp(tabgroup);
  populateEntityListsInTabGroup(tabgroup);
  onCreateBoxStatus__();

  // WARNING: The default behaviour of calling `onCreateBoxStatus()` upon entity creation is deprecated in this version of FAIMS Tools. If you never implemented this function, this warning can safely be ignored.
  inheritBoxStatusFields();
}


void onCreateBoxStatus__(){
  String ref      = "Box_Status";
  String event    = "create";
  String stmtsStr = getStatementsString(ref, event);
  execute(stmtsStr);
}



// Triggered after an existing record is loaded.
void onFetchBoxStatus__(){
  String ref      = "Box_Status";
  String event    = "fetch";
  String stmtsStr = getStatementsString(ref, event);
  execute(stmtsStr);
}



// Triggered after an existing record is saved.
void onSaveBoxStatus__(){
  String ref      = "Box_Status";
  String event    = "save";
  String stmtsStr = getStatementsString(ref, event);
  execute(stmtsStr);
}



// Triggered as a record is duplicated but before it's saved.
void onCopyBoxStatus__(){
  String ref      = "Box_Status";
  String event    = "copy";
  String stmtsStr = getStatementsString(ref, event);
  execute(stmtsStr);
}

void duplicateBoxStatus(){
  String tabgroup = "Box_Status";
  String uuidOld = getUuid(tabgroup);

  disableAutoSave(tabgroup);

  clearGpsInTabGroup(tabgroup);


  onCopyBoxStatus__();

  saveCallback = new SaveCallback() {
    onSave(uuid, newRecord) {
      setUuid(tabgroup, uuid);
      populateAuthorAndTimestamp(tabgroup);

      Boolean enable_autosave = true;

      fetchAll(getDuplicateRelnQuery(uuidOld), new FetchCallback(){
        onFetch(result) {
          Log.e("Module", result.toString());

          if (result != null && result.size() >= 1) {
            parentTabgroup__ = result.get(0).get(4);
            parentTabgroup__ = parentTabgroup__.replaceAll(" ", "_");
          }

          makeDuplicateRelationships(result, getUuid(tabgroup));

          showToast("{Duplicated_record}");
          dialog.dismiss();
        }
      });

      saveTabGroup(tabgroup);
    }
  };

  String extraDupeAttributes = "";
  fetchAll(getDuplicateAttributeQuery(getUuid(tabgroup), extraDupeAttributes), new FetchCallback(){
    onFetch(result) {
      excludeAttributes = new ArrayList();

      duplicateTabGroup(tabgroup, null, getExtraAttributes(result), excludeAttributes, saveCallback);
    }
  });
}

void deleteBoxStatus(){
  String tabgroup = "Box_Status";

  if (isNull(getUuid(tabgroup))) {
    cancelTabGroup(tabgroup, true);
  } else {
    showAlert("{Confirm_Deletion}", "{Press_OK_to_Delete_this_Record}", "reallyDeleteBoxStatus()", "doNotDelete()");
  }
}

void reallyDeleteBoxStatus(){
  String tabgroup = "Box_Status";
  deleteArchEnt(getUuid(tabgroup));
  cancelTabGroup(tabgroup, false);
}

void newNest(){
  String tabgroup = "Nest";


  setUuid(tabgroup, null);
  newTabGroup(tabgroup);
  populateAuthorAndTimestamp(tabgroup);
  populateEntityListsInTabGroup(tabgroup);
  onCreateNest__();

  // WARNING: The default behaviour of calling `onCreateNest()` upon entity creation is deprecated in this version of FAIMS Tools. If you never implemented this function, this warning can safely be ignored.
  inheritNestFields();
}


void onCreateNest__(){
  String ref      = "Nest";
  String event    = "create";
  String stmtsStr = getStatementsString(ref, event);
  execute(stmtsStr);
}



// Triggered after an existing record is loaded.
void onFetchNest__(){
  String ref      = "Nest";
  String event    = "fetch";
  String stmtsStr = getStatementsString(ref, event);
  execute(stmtsStr);
}



// Triggered after an existing record is saved.
void onSaveNest__(){
  String ref      = "Nest";
  String event    = "save";
  String stmtsStr = getStatementsString(ref, event);
  execute(stmtsStr);
}



// Triggered as a record is duplicated but before it's saved.
void onCopyNest__(){
  String ref      = "Nest";
  String event    = "copy";
  String stmtsStr = getStatementsString(ref, event);
  execute(stmtsStr);
}

void duplicateNest(){
  String tabgroup = "Nest";
  String uuidOld = getUuid(tabgroup);

  disableAutoSave(tabgroup);

  clearGpsInTabGroup(tabgroup);


  onCopyNest__();

  saveCallback = new SaveCallback() {
    onSave(uuid, newRecord) {
      setUuid(tabgroup, uuid);
      populateAuthorAndTimestamp(tabgroup);

      Boolean enable_autosave = true;

      fetchAll(getDuplicateRelnQuery(uuidOld), new FetchCallback(){
        onFetch(result) {
          Log.e("Module", result.toString());

          if (result != null && result.size() >= 1) {
            parentTabgroup__ = result.get(0).get(4);
            parentTabgroup__ = parentTabgroup__.replaceAll(" ", "_");
          }

          makeDuplicateRelationships(result, getUuid(tabgroup));

          showToast("{Duplicated_record}");
          dialog.dismiss();
        }
      });

      saveTabGroup(tabgroup);
    }
  };

  String extraDupeAttributes = "";
  fetchAll(getDuplicateAttributeQuery(getUuid(tabgroup), extraDupeAttributes), new FetchCallback(){
    onFetch(result) {
      excludeAttributes = new ArrayList();

      duplicateTabGroup(tabgroup, null, getExtraAttributes(result), excludeAttributes, saveCallback);
    }
  });
}

void deleteNest(){
  String tabgroup = "Nest";

  if (isNull(getUuid(tabgroup))) {
    cancelTabGroup(tabgroup, true);
  } else {
    showAlert("{Confirm_Deletion}", "{Press_OK_to_Delete_this_Record}", "reallyDeleteNest()", "doNotDelete()");
  }
}

void reallyDeleteNest(){
  String tabgroup = "Nest";
  deleteArchEnt(getUuid(tabgroup));
  cancelTabGroup(tabgroup, false);
}

void newNestMeasurement(){
  String tabgroup = "Nest_Measurement";


  setUuid(tabgroup, null);
  newTabGroup(tabgroup);
  populateAuthorAndTimestamp(tabgroup);
  populateEntityListsInTabGroup(tabgroup);
  onCreateNestMeasurement__();

  // WARNING: The default behaviour of calling `onCreateNestMeasurement()` upon entity creation is deprecated in this version of FAIMS Tools. If you never implemented this function, this warning can safely be ignored.
  inheritNestMeasurementFields();
  initNestStatus();
}


void onCreateNestMeasurement__(){
  String ref      = "Nest_Measurement";
  String event    = "create";
  String stmtsStr = getStatementsString(ref, event);
  execute(stmtsStr);
}



// Triggered after an existing record is loaded.
void onFetchNestMeasurement__(){
  String ref      = "Nest_Measurement";
  String event    = "fetch";
  String stmtsStr = getStatementsString(ref, event);
  execute(stmtsStr);
}



// Triggered after an existing record is saved.
void onSaveNestMeasurement__(){
  String ref      = "Nest_Measurement";
  String event    = "save";
  String stmtsStr = getStatementsString(ref, event);
  execute(stmtsStr);
}



// Triggered as a record is duplicated but before it's saved.
void onCopyNestMeasurement__(){
  String ref      = "Nest_Measurement";
  String event    = "copy";
  String stmtsStr = getStatementsString(ref, event);
  execute(stmtsStr);
}

void duplicateNestMeasurement(){
  String tabgroup = "Nest_Measurement";
  String uuidOld = getUuid(tabgroup);

  disableAutoSave(tabgroup);

  clearGpsInTabGroup(tabgroup);


  onCopyNestMeasurement__();

  saveCallback = new SaveCallback() {
    onSave(uuid, newRecord) {
      setUuid(tabgroup, uuid);
      populateAuthorAndTimestamp(tabgroup);

      Boolean enable_autosave = true;

      fetchAll(getDuplicateRelnQuery(uuidOld), new FetchCallback(){
        onFetch(result) {
          Log.e("Module", result.toString());

          if (result != null && result.size() >= 1) {
            parentTabgroup__ = result.get(0).get(4);
            parentTabgroup__ = parentTabgroup__.replaceAll(" ", "_");
          }

          makeDuplicateRelationships(result, getUuid(tabgroup));

          showToast("{Duplicated_record}");
          dialog.dismiss();
        }
      });

      saveTabGroup(tabgroup);
    }
  };

  String extraDupeAttributes = "";
  fetchAll(getDuplicateAttributeQuery(getUuid(tabgroup), extraDupeAttributes), new FetchCallback(){
    onFetch(result) {
      excludeAttributes = new ArrayList();

      duplicateTabGroup(tabgroup, null, getExtraAttributes(result), excludeAttributes, saveCallback);
    }
  });
}

void deleteNestMeasurement(){
  String tabgroup = "Nest_Measurement";

  if (isNull(getUuid(tabgroup))) {
    cancelTabGroup(tabgroup, true);
  } else {
    showAlert("{Confirm_Deletion}", "{Press_OK_to_Delete_this_Record}", "reallyDeleteNestMeasurement()", "doNotDelete()");
  }
}

void reallyDeleteNestMeasurement(){
  String tabgroup = "Nest_Measurement";
  deleteArchEnt(getUuid(tabgroup));
  cancelTabGroup(tabgroup, false);
}

void newEgg(){
  String tabgroup = "Egg";

  String autoNumSource = "";
  autoNumSource = getFieldValue("Control/Defaults/Next_Egg_ID");
  if (isNull(autoNumSource)) {
    showWarning("{Alert}","{A_next_ID_has_not_been_entered_please_provide_one}");
    return;
  }

  setUuid(tabgroup, null);
  newTabGroup(tabgroup);
  populateAuthorAndTimestamp(tabgroup);
  populateEntityListsInTabGroup(tabgroup);
  String autoNumDest = "";
  autoNumDest = "Egg/Egg/Egg_ID";
  incAutoNum(autoNumDest);
  onCreateEgg__();

  // WARNING: The default behaviour of calling `onCreateEgg()` upon entity creation is deprecated in this version of FAIMS Tools. If you never implemented this function, this warning can safely be ignored.
  inheritEggFields();
}


void onCreateEgg__(){
  String ref      = "Egg";
  String event    = "create";
  String stmtsStr = getStatementsString(ref, event);
  execute(stmtsStr);
}



// Triggered after an existing record is loaded.
void onFetchEgg__(){
  String ref      = "Egg";
  String event    = "fetch";
  String stmtsStr = getStatementsString(ref, event);
  execute(stmtsStr);
}



// Triggered after an existing record is saved.
void onSaveEgg__(){
  String ref      = "Egg";
  String event    = "save";
  String stmtsStr = getStatementsString(ref, event);
  execute(stmtsStr);
}



// Triggered as a record is duplicated but before it's saved.
void onCopyEgg__(){
  String ref      = "Egg";
  String event    = "copy";
  String stmtsStr = getStatementsString(ref, event);
  execute(stmtsStr);
}

void duplicateEgg(){
  String tabgroup = "Egg";
  String uuidOld = getUuid(tabgroup);

  disableAutoSave(tabgroup);
  String autoNumDest = "";
  autoNumDest = "Egg/Egg/Egg_ID";
  incAutoNum(autoNumDest);

  clearGpsInTabGroup(tabgroup);


  onCopyEgg__();

  saveCallback = new SaveCallback() {
    onSave(uuid, newRecord) {
      setUuid(tabgroup, uuid);
      populateAuthorAndTimestamp(tabgroup);

      Boolean enable_autosave = true;

      fetchAll(getDuplicateRelnQuery(uuidOld), new FetchCallback(){
        onFetch(result) {
          Log.e("Module", result.toString());

          if (result != null && result.size() >= 1) {
            parentTabgroup__ = result.get(0).get(4);
            parentTabgroup__ = parentTabgroup__.replaceAll(" ", "_");
          }

          makeDuplicateRelationships(result, getUuid(tabgroup));

          showToast("{Duplicated_record}");
          dialog.dismiss();
        }
      });

      saveTabGroup(tabgroup);
    }
  };

  String extraDupeAttributes = "";
  fetchAll(getDuplicateAttributeQuery(getUuid(tabgroup), extraDupeAttributes), new FetchCallback(){
    onFetch(result) {
      excludeAttributes = new ArrayList();

      duplicateTabGroup(tabgroup, null, getExtraAttributes(result), excludeAttributes, saveCallback);
    }
  });
}

void deleteEgg(){
  String tabgroup = "Egg";

  if (isNull(getUuid(tabgroup))) {
    cancelTabGroup(tabgroup, true);
  } else {
    showAlert("{Confirm_Deletion}", "{Press_OK_to_Delete_this_Record}", "reallyDeleteEgg()", "doNotDelete()");
  }
}

void reallyDeleteEgg(){
  String tabgroup = "Egg";
  deleteArchEnt(getUuid(tabgroup));
  cancelTabGroup(tabgroup, false);
}

void newChick(){
  String tabgroup = "Chick";

  String autoNumSource = "";
  autoNumSource = getFieldValue("Control/Defaults/Next_Chick_Chick_ID");
  if (isNull(autoNumSource)) {
    showWarning("{Alert}","{A_next_ID_has_not_been_entered_please_provide_one}");
    return;
  }

  setUuid(tabgroup, null);
  newTabGroup(tabgroup);
  populateAuthorAndTimestamp(tabgroup);
  populateEntityListsInTabGroup(tabgroup);
  String autoNumDest = "";
  autoNumDest = "Chick/Chick/Chick_Chick_ID";
  incAutoNum(autoNumDest);
  onCreateChick__();

  // WARNING: The default behaviour of calling `onCreateChick()` upon entity creation is deprecated in this version of FAIMS Tools. If you never implemented this function, this warning can safely be ignored.
  inheritChickFields();
}


void onCreateChick__(){
  String ref      = "Chick";
  String event    = "create";
  String stmtsStr = getStatementsString(ref, event);
  execute(stmtsStr);
}



// Triggered after an existing record is loaded.
void onFetchChick__(){
  String ref      = "Chick";
  String event    = "fetch";
  String stmtsStr = getStatementsString(ref, event);
  execute(stmtsStr);
}



// Triggered after an existing record is saved.
void onSaveChick__(){
  String ref      = "Chick";
  String event    = "save";
  String stmtsStr = getStatementsString(ref, event);
  execute(stmtsStr);
}



// Triggered as a record is duplicated but before it's saved.
void onCopyChick__(){
  String ref      = "Chick";
  String event    = "copy";
  String stmtsStr = getStatementsString(ref, event);
  execute(stmtsStr);
}

void duplicateChick(){
  String tabgroup = "Chick";
  String uuidOld = getUuid(tabgroup);

  disableAutoSave(tabgroup);
  String autoNumDest = "";
  autoNumDest = "Chick/Chick/Chick_Chick_ID";
  incAutoNum(autoNumDest);

  clearGpsInTabGroup(tabgroup);


  onCopyChick__();

  saveCallback = new SaveCallback() {
    onSave(uuid, newRecord) {
      setUuid(tabgroup, uuid);
      populateAuthorAndTimestamp(tabgroup);

      Boolean enable_autosave = true;

      fetchAll(getDuplicateRelnQuery(uuidOld), new FetchCallback(){
        onFetch(result) {
          Log.e("Module", result.toString());

          if (result != null && result.size() >= 1) {
            parentTabgroup__ = result.get(0).get(4);
            parentTabgroup__ = parentTabgroup__.replaceAll(" ", "_");
          }

          makeDuplicateRelationships(result, getUuid(tabgroup));

          showToast("{Duplicated_record}");
          dialog.dismiss();
        }
      });

      saveTabGroup(tabgroup);
    }
  };

  String extraDupeAttributes = "";
  fetchAll(getDuplicateAttributeQuery(getUuid(tabgroup), extraDupeAttributes), new FetchCallback(){
    onFetch(result) {
      excludeAttributes = new ArrayList();

      duplicateTabGroup(tabgroup, null, getExtraAttributes(result), excludeAttributes, saveCallback);
    }
  });
}

void deleteChick(){
  String tabgroup = "Chick";

  if (isNull(getUuid(tabgroup))) {
    cancelTabGroup(tabgroup, true);
  } else {
    showAlert("{Confirm_Deletion}", "{Press_OK_to_Delete_this_Record}", "reallyDeleteChick()", "doNotDelete()");
  }
}

void reallyDeleteChick(){
  String tabgroup = "Chick";
  deleteArchEnt(getUuid(tabgroup));
  cancelTabGroup(tabgroup, false);
}

void newChickMeasurement(){
  String tabgroup = "Chick_Measurement";


  setUuid(tabgroup, null);
  newTabGroup(tabgroup);
  populateAuthorAndTimestamp(tabgroup);
  populateEntityListsInTabGroup(tabgroup);
  onCreateChickMeasurement__();

  // WARNING: The default behaviour of calling `onCreateChickMeasurement()` upon entity creation is deprecated in this version of FAIMS Tools. If you never implemented this function, this warning can safely be ignored.
  inheritChickMeasurementFields();
}


void onCreateChickMeasurement__(){
  String ref      = "Chick_Measurement";
  String event    = "create";
  String stmtsStr = getStatementsString(ref, event);
  execute(stmtsStr);
}



// Triggered after an existing record is loaded.
void onFetchChickMeasurement__(){
  String ref      = "Chick_Measurement";
  String event    = "fetch";
  String stmtsStr = getStatementsString(ref, event);
  execute(stmtsStr);
}



// Triggered after an existing record is saved.
void onSaveChickMeasurement__(){
  String ref      = "Chick_Measurement";
  String event    = "save";
  String stmtsStr = getStatementsString(ref, event);
  execute(stmtsStr);
}



// Triggered as a record is duplicated but before it's saved.
void onCopyChickMeasurement__(){
  String ref      = "Chick_Measurement";
  String event    = "copy";
  String stmtsStr = getStatementsString(ref, event);
  execute(stmtsStr);
}

void duplicateChickMeasurement(){
  String tabgroup = "Chick_Measurement";
  String uuidOld = getUuid(tabgroup);

  disableAutoSave(tabgroup);

  clearGpsInTabGroup(tabgroup);

  populateCameraPictureGallery("Chick_Measurement/Chick_Measurement/Picture", new ArrayList());

  onCopyChickMeasurement__();

  saveCallback = new SaveCallback() {
    onSave(uuid, newRecord) {
      setUuid(tabgroup, uuid);
      populateAuthorAndTimestamp(tabgroup);

      Boolean enable_autosave = true;

      fetchAll(getDuplicateRelnQuery(uuidOld), new FetchCallback(){
        onFetch(result) {
          Log.e("Module", result.toString());

          if (result != null && result.size() >= 1) {
            parentTabgroup__ = result.get(0).get(4);
            parentTabgroup__ = parentTabgroup__.replaceAll(" ", "_");
          }

          makeDuplicateRelationships(result, getUuid(tabgroup));

          showToast("{Duplicated_record}");
          dialog.dismiss();
        }
      });

      saveTabGroup(tabgroup);
    }
  };

  String extraDupeAttributes = "";
  fetchAll(getDuplicateAttributeQuery(getUuid(tabgroup), extraDupeAttributes), new FetchCallback(){
    onFetch(result) {
      excludeAttributes = new ArrayList();
      excludeAttributes.add("Picture");

      duplicateTabGroup(tabgroup, null, getExtraAttributes(result), excludeAttributes, saveCallback);
    }
  });
}

void deleteChickMeasurement(){
  String tabgroup = "Chick_Measurement";

  if (isNull(getUuid(tabgroup))) {
    cancelTabGroup(tabgroup, true);
  } else {
    showAlert("{Confirm_Deletion}", "{Press_OK_to_Delete_this_Record}", "reallyDeleteChickMeasurement()", "doNotDelete()");
  }
}

void reallyDeleteChickMeasurement(){
  String tabgroup = "Chick_Measurement";
  deleteArchEnt(getUuid(tabgroup));
  cancelTabGroup(tabgroup, false);
}


void doNotDelete(){
  showToast("{Delete_Cancelled}");
}
addOnEvent("Login", "show", "removeNavigationButtons()");
addOnEvent("Control", "show", "removeNavigationButtons()");
addOnEvent("Day_of_Lay", "show", "removeNavigationButtons()");
addOnEvent("Actual_Day_of_Hatching", "show", "removeNavigationButtons()");
addOnEvent("Box", "show", "addNavigationButtons(\"Box\")");
addOnEvent("Box_Status", "show", "addNavigationButtons(\"Box_Status\")");
addOnEvent("Nest", "show", "addNavigationButtons(\"Nest\")");
addOnEvent("Nest_Measurement", "show", "addNavigationButtons(\"Nest_Measurement\")");
addOnEvent("Egg", "show", "addNavigationButtons(\"Egg\")");
addOnEvent("Chick", "show", "addNavigationButtons(\"Chick\")");
addOnEvent("Chick_Measurement", "show", "addNavigationButtons(\"Chick_Measurement\")");

/******************************************************************************/
/*                                   SEARCH                                   */
/******************************************************************************/
addOnEvent("Control/Search"               , "show"  , "search();");
addOnEvent("Control/Search/Entity_List"   , "click" , "loadEntity();");
addOnEvent("Control/Search/Search_Button" , "click" , "search()");
addOnEvent("Control/Search/Search_Term"   , "click" , "clearSearch()");
addOnEvent("Control/Search/Entity_Types"  , "click" , "search()");

entityTypes = new ArrayList();
entityTypes.add(new NameValuePair("{All}", ""));
entityTypes.add(new NameValuePair("{Box}", "Box"));
entityTypes.add(new NameValuePair("{Box_Status}", "Box Status"));
entityTypes.add(new NameValuePair("{Nest}", "Nest"));
entityTypes.add(new NameValuePair("{Nest_Visit}", "Nest Measurement"));
entityTypes.add(new NameValuePair("{Egg}", "Egg"));
entityTypes.add(new NameValuePair("{Chick}", "Chick"));
entityTypes.add(new NameValuePair("{Chick_Measurement}", "Chick Measurement"));
populateDropDown("Control/Search/Entity_Types", entityTypes);

void clearSearch(){
  setFieldValue("Control/Search/Search_Term","");
}

void search(){
  String tabgroup = "Control";
  String refEntityList  = tabgroup + "/Search/Entity_List";
  String refSearchTerm  = tabgroup + "/Search/Search_Term";
  String refEntityTypes = tabgroup + "/Search/Entity_Types";

  String type = getFieldValue(refEntityTypes);
  String term = getFieldValue(refSearchTerm);
  String searchQuery = "SELECT uuid, response "+
                       "  FROM latestNonDeletedArchEntFormattedIdentifiers  "+
                       " WHERE uuid in (SELECT uuid "+
                       "                  FROM latestNonDeletedArchEntIdentifiers "+
                       "                 WHERE measure LIKE '"+term+"'||'%'  "+
                       "                   AND ( aenttypename LIKE '"+type+"' OR '' = '"+type+"' ) "+
                       "                )  "+
                       " ORDER BY response "+
                       " LIMIT ? "+
                       "OFFSET ? ";

  populateCursorList(refEntityList, searchQuery, 25);
  refreshTabgroupCSS(tabgroup);

  Log.d("Module", "Search query: " + searchQuery);
}

void loadBoxFrom(String uuid) {
  String tabgroup = "Box";
  setUuid(tabgroup, uuid);
  if (isNull(uuid)) return;

  FetchCallback cb = new FetchCallback() {
    onFetch(result) {
      populateEntityListsInTabGroup(tabgroup);
      // WARNING: The default behaviour of calling `onFetchBox()` upon fetching an entity is deprecated in this version of FAIMS Tools. If you never implemented this function, this warning can safely be ignored.
      onFetchBox__();
    }
  };

  showTabGroup(tabgroup, uuid, cb);
}

void loadBoxStatusFrom(String uuid) {
  String tabgroup = "Box_Status";
  setUuid(tabgroup, uuid);
  if (isNull(uuid)) return;

  FetchCallback cb = new FetchCallback() {
    onFetch(result) {
      populateEntityListsInTabGroup(tabgroup);
      // WARNING: The default behaviour of calling `onFetchBoxStatus()` upon fetching an entity is deprecated in this version of FAIMS Tools. If you never implemented this function, this warning can safely be ignored.
      onFetchBoxStatus__();
    }
  };

  showTabGroup(tabgroup, uuid, cb);
}

void loadNestFrom(String uuid) {
  String tabgroup = "Nest";
  setUuid(tabgroup, uuid);
  if (isNull(uuid)) return;

  FetchCallback cb = new FetchCallback() {
    onFetch(result) {
      populateEntityListsInTabGroup(tabgroup);
      // WARNING: The default behaviour of calling `onFetchNest()` upon fetching an entity is deprecated in this version of FAIMS Tools. If you never implemented this function, this warning can safely be ignored.
      onFetchNest__();
    }
  };

  showTabGroup(tabgroup, uuid, cb);
}

void loadNestMeasurementFrom(String uuid) {
  String tabgroup = "Nest_Measurement";
  setUuid(tabgroup, uuid);
  if (isNull(uuid)) return;

  FetchCallback cb = new FetchCallback() {
    onFetch(result) {
      populateEntityListsInTabGroup(tabgroup);
      // WARNING: The default behaviour of calling `onFetchNestMeasurement()` upon fetching an entity is deprecated in this version of FAIMS Tools. If you never implemented this function, this warning can safely be ignored.
      onFetchNestMeasurement__();
    }
  };

  showTabGroup(tabgroup, uuid, cb);
}

void loadEggFrom(String uuid) {
  String tabgroup = "Egg";
  setUuid(tabgroup, uuid);
  if (isNull(uuid)) return;

  FetchCallback cb = new FetchCallback() {
    onFetch(result) {
      populateEntityListsInTabGroup(tabgroup);
      // WARNING: The default behaviour of calling `onFetchEgg()` upon fetching an entity is deprecated in this version of FAIMS Tools. If you never implemented this function, this warning can safely be ignored.
      onFetchEgg__();
    }
  };

  showTabGroup(tabgroup, uuid, cb);
}

void loadChickFrom(String uuid) {
  String tabgroup = "Chick";
  setUuid(tabgroup, uuid);
  if (isNull(uuid)) return;

  FetchCallback cb = new FetchCallback() {
    onFetch(result) {
      populateEntityListsInTabGroup(tabgroup);
      // WARNING: The default behaviour of calling `onFetchChick()` upon fetching an entity is deprecated in this version of FAIMS Tools. If you never implemented this function, this warning can safely be ignored.
      onFetchChick__();
    }
  };

  showTabGroup(tabgroup, uuid, cb);
}

void loadChickMeasurementFrom(String uuid) {
  String tabgroup = "Chick_Measurement";
  setUuid(tabgroup, uuid);
  if (isNull(uuid)) return;

  FetchCallback cb = new FetchCallback() {
    onFetch(result) {
      populateEntityListsInTabGroup(tabgroup);
      // WARNING: The default behaviour of calling `onFetchChickMeasurement()` upon fetching an entity is deprecated in this version of FAIMS Tools. If you never implemented this function, this warning can safely be ignored.
      onFetchChickMeasurement__();
    }
  };

  showTabGroup(tabgroup, uuid, cb);
}


/******************************************************************************/
/*                          TAKE FROM GPS BUTTON(S)                           */
/******************************************************************************/
addOnEvent("Box/Box/Take_From_GPS", "click", "takePoint(\"Box\")");

/* Takes the current point using gps. */
takePoint(String tabgroup) {
  Map tabgroupToTabRef = new HashMap();
  tabgroupToTabRef.put("Box", "Box/Box/");

  String archEntType = tabgroup.replaceAll("_", " ");
  String currentUuid = getUuid(tabgroup);
  if (isNull(currentUuid)){
    showToast("Please enter data first and let a save occur.");
    return;
  }

  Object position = getGPSPosition();
  if (position == null) {
    showToast("{GPS_Not_Initialised}");
    return;
  }

  Object projPosition = getGPSPositionProjected();
  Double latitude     = position.getLatitude();
  Double longitude    = position.getLongitude();
  Double northing     = projPosition.getLatitude();
  Double easting      = projPosition.getLongitude();

  samplePoint = new Point(new MapPos(easting, northing), null, (PointStyle) null, null);
  ArrayList geolist = new ArrayList();
  geolist.add(samplePoint);

  String accuracy = "" + getGPSEstimatedAccuracy();
  setFieldValue(tabgroupToTabRef.get(tabgroup) + "Accuracy", accuracy);

  saveArchEnt(currentUuid, archEntType, geolist, null, new SaveCallback() {
    onSave(uuid, newRecord) {
      print("[takePoint()] Added geometry: " + geolist);
      fillInGPS(tabgroup);
    }
  });
}

/* Sets the value of GPS views for the given tab path. */
fillInGPS(String tabgroup) {
  Map tabgroupToTabRef = new HashMap();
  tabgroupToTabRef.put("Box", "Box/Box/");

  String currentUuid = getUuid(tabgroup);
  if (isNull(currentUuid)) {
    return;
  }

  String query = "SELECT x(transform(geospatialcolumn,                4326)) as longtiude, " +
                 "       y(transform(geospatialcolumn,                4326)) as latitude, " +
                 "       x(transform(geospatialcolumn, "+getModuleSrid()+")) as easting, " +
                 "       y(transform(geospatialcolumn, "+getModuleSrid()+")) as northing " +
                 "  FROM latestnondeletedarchent, vocabulary " +
                 " WHERE uuid = '" + currentUuid + "';";

  fetchOne(query, new FetchCallback() {
    onFetch(result) {
      print("[fillInGPS()] Fetched DB transformed geometry: " + result);
      setFieldValue(tabgroupToTabRef.get(tabgroup) + "Longitude" , result.get(0));
      setFieldValue(tabgroupToTabRef.get(tabgroup) + "Latitude"  , result.get(1));
      setFieldValue(tabgroupToTabRef.get(tabgroup) + "Easting"   , result.get(2));
      setFieldValue(tabgroupToTabRef.get(tabgroup) + "Northing"  , result.get(3));
    }
  });
}

clearGpsInTabGroup(String tabgroup) {
  Map tabgroupToTabRef = new HashMap();
  tabgroupToTabRef.put("Box", "Box/Box/");


  String tabRef = tabgroupToTabRef.get(tabgroup);
  if (isNull(tabRef)) return;

  clearGpsInTab(tabRef);
}

clearGpsInTab(String tabRef) {
  setFieldValue(tabRef + "Accuracy"  , "");
  setFieldValue(tabRef + "Latitude"  , "");
  setFieldValue(tabRef + "Longitude" , "");
  setFieldValue(tabRef + "Easting"   , "");
  setFieldValue(tabRef + "Northing"  , "");
}

/******************************************************************************/
/*                       AUTONUMBERING HELPER FUNCTIONS                       */
/******************************************************************************/
/*
 * If value of field specified by `ref` is null, sets the field to `defaultVal`,
 * otherwise increments its value.
 *
 * Returns the value the field was updated to.
 */
incField(String ref, Integer defaultVal) {
  String val = getFieldValue(ref);

  if (isNull(val)) {
    setFieldValue(ref, defaultVal);
    return defaultVal;
  }

  Integer inc = Integer.parseInt(val) + 1;
  setFieldValue(ref, inc);
  insertIntoLocalSettings(ref, inc.toString());

  return inc;
}

/* Increments the field at `ref` or returns null if it does not contain a
 * number.
 */
incField(String ref) {
  return incField(ref, 1);
}

getStartingIdPaths() {
  List l = new ArrayList();
  l.add("Control/Defaults/Next_Egg_ID");
  l.add("Control/Defaults/Next_Chick_Chick_ID");

  return l;
}

loadStartingId(String ref) {
  // If there's already a value in the field, we don't need to load one.
  String val = getFieldValue(ref);
  if (!isNull(val)) {
    return;
  }

  // Load a value into the field. Set it to 1 if no value has been previously
  // saved.
  String idQ = "SELECT value FROM localSettings WHERE key = '" + ref + "';";
  fetchOne(idQ, new FetchCallback() {
    onFetch(result) {
      if (isNull(result)) setFieldValue(ref, "1"          );
      else                setFieldValue(ref, result.get(0));
    }
  });
}

loadStartingIds() {
  List l = getStartingIdPaths();

  for (ref : l) {
    loadStartingId(ref);
  }
}

addOnEvent("Control", "show", "loadStartingIds()");

/*
 * Sets bindings to save autonum'd fields whenever they're blurred.
 */
for (ref : getStartingIdPaths()) {
  onFocus(ref, null, "insertIntoLocalSettings(\"" + ref + "\", getFieldValue(\"" + ref + "\"));");
}

incAutoNum(String destPath) {
  Map destToSource = new HashMap();
  destToSource.put("Egg/Egg/Egg_ID", "Control/Defaults/Next_Egg_ID");
  destToSource.put("Chick/Chick/Chick_Chick_ID", "Control/Defaults/Next_Chick_Chick_ID");

  String sourcePath = destToSource.get(destPath);
  String destVal    = getFieldValue(sourcePath);
  setFieldValue(destPath, destVal);
  incField(sourcePath);
}

/******************************************************************************/
/*                POPULATION OF ENTITY AND CHILD ENTITY LISTS                 */
/******************************************************************************/
/*
 * `viewType`   the type of GUI element to be populated. It can either equal
 *              "DropDown" or "List".
 * `path`       the reference of the GUI element to be populated.
 * `parentUuid` the parent in the relationship denoted by `relType`.
 * `entType`    the type of the entities the menu will be populated with.
 * `relType`    the name of the relationship the children are to be in with the
 *              entity denoted by `parentUuid`.
 */
void populateMenuWithEntities (
  String viewType,
  String path,
  String parentUuid,
  String entType,
  String relType
) {
  String getChildEntitiesQ = "" +
    "SELECT childuuid, response "+
    "  FROM parentchild JOIN latestNonDeletedArchEntFormattedIdentifiers ON (childuuid = uuid) " +
    "  JOIN createdmodifiedatby USING (uuid) " +
    " WHERE relationshipid IN (SELECT relationshipid  " +
    "                            FROM latestnondeletedrelationship JOIN relntype USING (relntypeid) " +
    "                           WHERE relntypename = '"+relType+"') " +
    "   AND parentuuid = " + parentUuid + " " +
    "   AND (childaenttypename = '"+entType+"' OR '"+entType+"' = '') " +
    " ORDER BY createdat DESC ";

  String getEntitiesQ = "" +
    "SELECT uuid, response "+
    "  FROM latestNonDeletedArchEntFormattedIdentifiers  "+
    " WHERE uuid in (SELECT uuid "+
    "                  FROM latestNonDeletedArchEntIdentifiers "+
    "                 WHERE aenttypename = '"+entType+"' OR '"+entType+"' = '' " +
    "               )  "+
    " ORDER BY response ";

  String q = null;
  if (relType.equals("")) {
    q = getEntitiesQ;
  } else {
    q = getChildEntitiesQ;
  }

  FetchCallback cbPopulateDropDown = new FetchCallback() {
    onFetch(result) {
      populateDropDown(path, result, true);
    }
  };

  switch (viewType) {
    case "DropDown":
      fetchAll(q, cbPopulateDropDown);
      break;
    case "List":
      q += " LIMIT ? OFFSET ? ";
      populateCursorList(path, q, 25);
      break;
    default:
      Log.e("populateMenuWithEntities ", "Unexpected type '" + viewType + "'");
  }
}

void populateEntityListsInTabGroup(String tabGroup) {
  if (isNull(tabGroup)) {
    return;
  }

  for (m : ENTITY_MENUS) {
    String path         = m[1];
    String menuTabGroup = getTabGroupRef(path);
    String functionCall = getEntityMenuPopulationFunction(m);

    if (menuTabGroup.equals(tabGroup))
      execute(functionCall);
  }
}

String getEntityMenuPopulationFunction(String[] menuDescriptor) {
  String viewType       = menuDescriptor[0];
  String path           = menuDescriptor[1];
  String parentUuidCall = menuDescriptor[2];
  String entType        = menuDescriptor[3];
  String relType        = menuDescriptor[4];

  String functionCall = "";
  functionCall += "populateMenuWithEntities(";
  functionCall += "\"" + viewType       + "\"";
  functionCall += ", ";
  functionCall += "\"" + path           + "\"";
  functionCall += ", ";
  functionCall +=        parentUuidCall       ;
  functionCall += ", ";
  functionCall += "\"" + entType        + "\"";
  functionCall += ", ";
  functionCall += "\"" + relType        + "\"";
  functionCall += ")";

  return functionCall;
}

ENTITY_MENUS = new ArrayList();
ENTITY_MENUS.add(new String[] {
  "List",
  "Control/Control/Existing_Boxes",
  "getUuid(\"Control\")",
  "Box",
  ""
});
ENTITY_MENUS.add(new String[] {
  "List",
  "Box/Box/Box_Statuses",
  "getUuid(\"Box\")",
  "Box Status",
  "Box - Box Status",
});
ENTITY_MENUS.add(new String[] {
  "List",
  "Box/Box/Existing_Nests",
  "getUuid(\"Box\")",
  "Nest",
  "Box - Nest",
});
ENTITY_MENUS.add(new String[] {
  "List",
  "Nest/Nest/Nest_Measurements",
  "getUuid(\"Nest\")",
  "Nest Measurement",
  "Nest - Nest Measurement",
});
ENTITY_MENUS.add(new String[] {
  "List",
  "Nest/Egg_Chick/Existing_Eggs",
  "getUuid(\"Nest\")",
  "Egg",
  "Nest - Egg",
});
ENTITY_MENUS.add(new String[] {
  "List",
  "Nest/Egg_Chick/Existing_Chicks",
  "getUuid(\"Nest\")",
  "Chick",
  "Nest - Chick",
});
ENTITY_MENUS.add(new String[] {
  "List",
  "Chick/Chick/Existing_Chick_Measurements",
  "getUuid(\"Chick\")",
  "Chick Measurement",
  "Chick - Chick Measurement",
});
for (m : ENTITY_MENUS) {
  String path         = m[1];
  String functionCall = getEntityMenuPopulationFunction(m);

  execute(functionCall);
}
addOnEvent("Control/Control/Existing_Boxes", "click", "loadEntity()");
addOnEvent("Box/Box/Box_Statuses", "click", "loadEntity()");
addOnEvent("Box/Box/Existing_Nests", "click", "loadEntity()");
addOnEvent("Nest/Nest/Nest_Measurements", "click", "loadEntity()");
addOnEvent("Nest/Egg_Chick/Existing_Eggs", "click", "loadEntity()");
addOnEvent("Nest/Egg_Chick/Existing_Chicks", "click", "loadEntity()");
addOnEvent("Chick/Chick/Existing_Chick_Measurements", "click", "loadEntity()");

/******************************************************************************/
/*                             HANDWRITTEN LOGIC                              */
/******************************************************************************/

/***************************** FIELD INHERITANCE ******************************/
/* Careful! I'm using weird formatting in here for my if statements.          */
/******************************************************************************/
copyFromMenuToInput(src, dst) {
  String val = getMenuValue(src);
  setFieldValue(dst, val);
}

inheritBoxFields() {
  return;
}

inheritNestFields() {
  if (parentTabgroup__.equals("Box"))
  copyFieldValue(
    "Box/Box/Box_Box_Prefix",
    "Nest/Nest/Nest_Box_Prefix"
  );
  if (parentTabgroup__.equals("Box"))
  copyFieldValue(
    "Box/Box/Box_Box_ID",
    "Nest/Nest/Nest_Box_ID",
    false
  );
  if (parentTabgroup__.equals("Box"))
  copyFromMenuToInput(
    "Box/Box/Box_Location_Name",
    "Nest/Nest/Nest_Location_Name"
  );
}

inheritEggFields() {
  if (parentTabgroup__.equals("Nest"))
  copyFieldValue(
    "Nest/Nest/Nest_Box_Prefix",
    "Egg/Egg/Egg_Box_Prefix"
  );
  if (parentTabgroup__.equals("Nest"))
  copyFieldValue(
    "Nest/Nest/Nest_Box_ID",
    "Egg/Egg/Egg_Box_ID",
    false
  );
  if (parentTabgroup__.equals("Nest"))
  copyFieldValue(
    "Nest/Nest/Nest_Nest_ID",
    "Egg/Egg/Egg_Nest_ID",
    false
  );
  if (parentTabgroup__.equals("Nest"))
  copyFieldValue(
    "Nest/Nest/Nest_Location_Name",
    "Egg/Egg/Egg_Location_Name",
    false
  );
}

inheritChickFields() {
  if (parentTabgroup__.equals("Nest"))
  copyFieldValue(
    "Nest/Nest/Nest_Box_Prefix",
    "Chick/Chick/Chick_Box_Prefix"
  );
  if (parentTabgroup__.equals("Nest"))
  copyFieldValue(
    "Nest/Nest/Nest_Box_ID",
    "Chick/Chick/Chick_Box_ID",
    false
  );
  if (parentTabgroup__.equals("Nest"))
  copyFieldValue(
    "Nest/Nest/Nest_Nest_ID",
    "Chick/Chick/Chick_Nest_ID",
    false
  );
  if (parentTabgroup__.equals("Nest"))
  copyFieldValue(
    "Nest/Nest/Nest_Location_Name",
    "Chick/Chick/Chick_Location_Name",
    false
  );
}

inheritMeasurementFields() {
  if (parentTabgroup__.equals("Chick"))
  copyFieldValue(
    "Chick/Chick/Chick_Chick_ID",
    "Measurement/Measurement/Measurement_Chick_ID",
    false
  );
}

inheritBoxStatusFields() {
  if (parentTabgroup__.equals("Box"))
  copyFieldValue(
    "Box/Box/Box_Box_Prefix",
    "Box_Status/Box_Status/Box_Status_Box_Prefix"
  );
  if (parentTabgroup__.equals("Box"))
  copyFieldValue(
    "Box/Box/Box_Box_ID",
    "Box_Status/Box_Status/Box_Status_Box_ID",
    false
  );
}

inheritNestMeasurementFields() {
  if (parentTabgroup__.equals("Nest"))
  copyFieldValue(
    "Nest/Nest/Nest_Nest_ID",
    "Nest_Measurement/Nest_Measurement/Nest_Measurement_Nest_ID",
    false
  );
}

inheritChickMeasurementFields() {
  if (parentTabgroup__.equals("Chick"))
  copyFieldValue(
    "Chick/Chick/Chick_Chick_ID",
    "Chick_Measurement/Chick_Measurement/Chick_Measurement_Chick_ID",
    false
  );
}
/*************************** CREATE NEW NEST BUTTON ***************************/
// Overrides the autogenerated fuction
onClickBoxAddNewNest () {
  String tabgroup = "Box";
  String boxUuid  = getUuid(tabgroup);
  if (isNull(getUuid(tabgroup))){
    showToast("{You_must_save_this_tabgroup_first}");
    return;
  }

  String q = "";
  q += " /* Get the Box Status attribute.";
  q += "  */";
  q += " SELECT vocabname";
  q += " FROM   latestnondeletedaentvalue";
  q += " JOIN   attributekey USING (attributeid)";
  q += " JOIN   vocabulary   USING (attributeid, vocabid)";
  q += " WHERE  attributename = 'Box Status'";
  q += " AND    uuid IN (";
  q += " ";
  q += "     /* Select latest Box Status uuid";
  q += "      */";
  q += "     SELECT    childuuid";
  q += "       FROM    parentchild";
  q += "       JOIN    createdmodifiedatby ON (uuid=childuuid)";
  q += "      WHERE    parentuuid         = '{boxUuid}'";
  q += "        AND    parentaenttypename = 'Box'";
  q += "        AND    childaenttypename  = 'Box Status'";
  q += "      ORDER BY createdat DESC";
  q += "      LIMIT    1";
  q += " ";
  q += " )";
  q  = replaceFirst(q, "{boxUuid}", boxUuid);

  FetchCallback cb = new FetchCallback() {
    onFetch(result) {
      if      ( result                   == null) boxIsNotActive(""           );
      else if ( result.size()            == 0   ) boxIsNotActive(""           );
      else if ( result.get(0)            == null) boxIsNotActive(""           );
      else if (!result.get(0).equals("{Active}")) boxIsNotActive(result.get(0));
      else                                        boxIsActive();
    }
  };

  fetchOne(q, cb);
}

boxIsActive() {
  String tabgroup = "Box";
  parentTabgroup   = tabgroup;
  parentTabgroup__ = tabgroup;
  newNest();
}

boxIsNotActive(String valBoxStatus) {
  String fmtBoxStatus = "";
  if (valBoxStatus.equals("")) {
    fmtBoxStatus = "nothing";
  } else {
    fmtBoxStatus = "'%s'";
    fmtBoxStatus = replaceFirst(fmtBoxStatus, valBoxStatus);
  }

  msgHead  = "Cannot Create Nest";
  msgBody  = "This Box must have its Box Status set to 'Active' before a ";
  msgBody += "Nest can be created. However, it is currently set to %s.";
  msgBody  = replaceFirst(msgBody, fmtBoxStatus);
  showWarning(msgHead, msgBody);
}
/****************** COMPUTE DAY OF HATCHING ESTIMATE BUTTON *******************/
addOnEvent("Nest/Nest/Compute_Estimated_Day_of_Hatching", "click", "estimateDayOfHatching()");

estimateDayOfHatching() {
  Integer daysToHatch = 12;

  String refDayOfLay      = "Nest/Nest/Day_of_Lay";
  String refDayOfHatching = "Nest/Nest/Estimated_Day_of_Hatching";

  String dayOfLay      = getFieldValue(refDayOfLay     );
  String dayOfHatching = getFieldValue(refDayOfHatching);

  // Set input and output formats
  fmtIn   = "yyyy/MM/dd";
  fmtOut  = "yyyy/MM/dd";

  dateFmtIn  = new java.text.SimpleDateFormat(fmtIn );
  dateFmtOut = new java.text.SimpleDateFormat(fmtOut);

  // Get lay date (by parsing it)
  Date dateLay = dateFmtIn.parse(dayOfLay);

  // Get hatching date (by adding to the lay date)
  Calendar cal = Calendar.getInstance();
  cal.setTime(dateLay);
  cal.add(Calendar.DATE, daysToHatch);

  Date dateOfHatching = cal.getTime();

  // Format and write out date
  dateStr = dateFmtOut.format(dateOfHatching);
  setFieldValue(refDayOfHatching, dateStr);
}
onClickNestSetActualDayofHatching () {
  msgHead  = "Proceed To Date Picker?";
  msgBody  = "Have you established the Actual Day of Hatching? If not, press 'Cancel' and ";
  msgBody += "return. If yes, press 'OK' and select date from date picker. ";
  msgBody += "Once selected, the 'Actual Day of Hatching' can only be edited but not ";
  msgBody += "blanked.";

  cbOkay   = "goToSetActualDayofHatching()";
  cbCancel = "";

  showAlert(msgHead, msgBody, cbOkay, cbCancel);
}

goToSetActualDayofHatching() {
  newTab("Actual_Day_of_Hatching", true);
}


addOnEvent("Actual_Day_of_Hatching/Actual_Day_of_Hatching/Set_Actual_Day_of_Hatching", "click", "setActualDayOfHatching()");
addOnEvent("Actual_Day_of_Hatching/Actual_Day_of_Hatching/Cancel",         "click", "goBack()");

setActualDayOfHatching() {
  src = "Actual_Day_of_Hatching/Actual_Day_of_Hatching/Actual_Day_of_Hatching";
  dst = "Nest/Nest/Actual_Day_of_Hatching";

  // Change the date picker's DD/MM/YYYY format to YYYY/MM/DD
  val = getFieldValue(src);
  val = val.split("/")[2] + "/" +
        val.split("/")[1] + "/" +
        val.split("/")[0];

  setFieldValue(dst, val);

  goBack();
}
/*************************** NEST COMPLETED BUTTON ****************************/
addOnEvent("Nest/Nest/Nest_Completed", "click", "nestCompleted()");

nestCompleted() {
  String msgHead;
  String msgBody;

  msgHead  = "Is this Nest Really Complete?";
  msgBody  = "If this Nest is complete, tap 'OK' to set the 'Nest Completed ";
  msgBody += "at' field to the current time, or tap 'Cancel' to continue ";
  msgBody += "editing.";

  showAlert(msgHead, msgBody, "nestCompletedOk()", "nestCompletedCancel()");
}

nestCompletedOk() {
  String refTimestamp = "Nest/Nest/Nest_Completed_at";
  String timestamp = getTimestampNow();

  setFieldValue(refTimestamp, timestamp);
}

nestCompletedCancel() {
  return;
}
/********************************** REVISITS **********************************/
addOnEvent("Control/Revisit/Compute_Revisits",     "click", "computeRevisits()");
//addOnEvent("Control/Revisit/Perform_Next_Revisit", "click", "performNextRevisit()");
addOnEvent("Control/Revisit/Revisit",              "show",  "populateDaysDropdown()");

populateDaysDropdown() {
  String daysRef = "Control/Revisit/Days";

  List days = new ArrayList();
  days.add(new NameValuePair("Day before Yesterday" , "-2 Days"));
  days.add(new NameValuePair("Yesterday"            , "-1 Day" ));
  days.add(new NameValuePair("Today"                , "+0 days"));
  days.add(new NameValuePair("Tomorrow"             , "+1 Day" ));
  days.add(new NameValuePair("Day After Tomorrow"   , "+2 Days"));

  populateDropDown(daysRef, days);
}

getRevisitsQuery() {
  String daysRef = "Control/Revisit/Days";
  String daysVal = getFieldValue(daysRef);

  String q = "";
  q += " select uuid, dayDue, response, tasks";
  q += "   from (select dayDue, tasks, parentchild.parentuuid as uuid";
  q += "         from (select dayDue, 'Check: '||group_concat(taskName, ', ') as tasks, nestuuid";
  q += "                 from taskList";
  q += "               group by nestuuid, dayDue";
  q += "               order by aenttypenameorder, dayDue";
  q += "                )";
  q += "           JOIN parentchild on (parentchild.childuuid = nestuuid)";
  q += "          where parentchild.parentaenttypename = 'Box'";
  q += "            and dayDue >= date(current_date, '{days}')";
  q += "          order by dayDue";
  q += "           ) JOIN latestNonDeletedArchEntFormattedIdentifiers USING (uuid)";
  q += " ";
  q += "   order by dayDue";
  q  = replaceFirst(q, "{days}", daysVal);

  return q;
}

computeRevisits() {
  String q        = getRevisitsQuery();
  String tableRef = "Control/Revisit/Revisit";

  headers        = new ArrayList();
  actionName     = "Revisit";
  actionIdx      = 0;
  actionCallback = "loadEntityFromTable()";

  headers.add("");
  headers.add("Day Due");
  headers.add("Record");
  headers.add("Task(s)");

  populateTableRaw(
      tableRef,
      q,
      headers,
      actionName,
      actionIdx,
      actionCallback
  );
}

performNextRevisit() {
  String q = getRevisitsQuery();
  FetchCallback loadNextEntity = new FetchCallback() {
    onFetch(result){
      if      ( result        == null) { ; }
      else if ( result.size() == 0   ) { ; }
      else if ( result.get(0) == null) { ; }
      else                             loadEntityFrom(result.get(0));
    }
  };

  fetchOne(q, loadNextEntity);
}

loadEntityFromTable() {
  uuid = getTableValue();
  loadEntityFrom(uuid); // Auto-gen'd function
}

makeTableViewViews() {
  fetchOne(" drop view if exists truncFormattedIdentifier;", null);
  fetchOne(" create view truncFormattedIdentifier as" +
           "     select uuid, format(trim(formatstring,'-'), null, measure, freetext, certainty) as response" +
           "                                 from latestnondeletedaentvalue join attributekey using (attributeid)" +
           "                                 where attributename in ('Nest Nest ID');", null);
  fetchOne(" drop view if exists tasklist;", null);
  fetchOne(" create view tasklist as" +
           "    select date(replace(measure,'/','-'), '+3 day') as dayDue, response as taskName, uuid as nestuuid, 3 as aenttypenameorder" +
           "     from latestnondeletedaentvalue" +
           "     join truncFormattedIdentifier as task using (uuid)" +
           "     join attributekey using (attributeid)" +
           "    where attributename = 'Actual Day of Hatching'" +
           "    union" +
           "   select date(replace(measure,'/','-'), '+7 day') as dayDue, response as taskName, uuid as nestuuid, 2 as aenttypenameorder" +
           "     from latestnondeletedaentvalue" +
           "     join truncFormattedIdentifier as task using (uuid)" +
           "     join attributekey using (attributeid)" +
           "    where attributename = 'Actual Day of Hatching'" +
           "    union" +
           "   select date(replace(measure,'/','-'), '+11 day') as dayDue, response as taskName, uuid as nestuuid, 2 as aenttypenameorder" +
           "     from latestnondeletedaentvalue" +
           "     join truncFormattedIdentifier as task using (uuid)" +
           "     join attributekey using (attributeid)" +
           "    where attributename = 'Actual Day of Hatching'" +
           "    union" +
           "   select date(replace(measure,'/','-'), '+18 day') as dayDue, response as taskName, uuid as nestuuid, 2 as aenttypenameorder" +
           "     from latestnondeletedaentvalue" +
           "     join truncFormattedIdentifier as task using (uuid)" +
           "     join attributekey using (attributeid)" +
           "    where attributename = 'Actual Day of Hatching'" +
           "    order by taskName desc, aenttypenameorder, dayDue;", null);
}
makeTableViewViews();
/*********************** HATCHED CHICK COUNT POPULATION ***********************/
addOnEvent("Nest_Measurement/Nest_Measurement/Take_Current_Chick_Counts", "click", "populateHatchedChickCount()");

populateHatchedChickCount() {
  String nestMeasurementUuid = getUuid("Nest_Measurement");
  if (isNull(nestMeasurementUuid)) {
    showToast("{You_must_save_this_tabgroup_first}");
    return;
  }

  String refLive = "Nest_Measurement/Nest_Measurement/Hatched_Chick_Count_Live";
  String refDead = "Nest_Measurement/Nest_Measurement/Hatched_Chick_Count_Dead";

  // Produce queries
  Boolean isLive;
  isLive = true;  qLive = getHatchedChickCountQuery(isLive, nestMeasurementUuid);
  isLive = false; qDead = getHatchedChickCountQuery(isLive, nestMeasurementUuid);

  // Set up callbacks
  FetchCallback populateLive = new FetchCallback() {
    onFetch(result) {
      String count = result.get(0).get(0);
      setFieldValue(refLive, count);
    }
  };
  FetchCallback populateDead = new FetchCallback() {
    onFetch(result) {
      String count = result.get(0).get(0);
      setFieldValue(refDead, count);
    }
  };

  // Fetch
  fetchAll(qLive, populateLive);
  fetchAll(qDead, populateDead);
}

getHatchedChickCountQuery(Boolean isLive, nestMeasurementUuid) {
  String chickAliveVocabName = "";
  if (isLive) chickAliveVocabName = "{Yes}";
  else        chickAliveVocabName = "{No}";

  String q = "";
  q += " SELECT COUNT(uuid)";
  q += "   FROM latestnondeletedaentvalue";
  q += "   JOIN attributekey USING (attributeid)";
  q += "   JOIN vocabulary USING (vocabid)";
  q += "  WHERE vocabname = '{chickAliveVocabName}'";
  q += "    AND uuid IN (";
  q += " SELECT childuuid";
  q += "                   FROM parentchild JOIN latestnondeletedarchent on (uuid = childuuid)";
  q += "                  WHERE childaenttypename = 'Chick Measurement'";
  q += "                    AND parentuuid IN (SELECT childuuid";
  q += "                                         FROM parentchild";
  q += "                                        WHERE childaenttypename = 'Chick'";
  q += "                                          AND parentuuid in (select parentuuid";
  q += "                                                                  from parentchild";
  q += "                                                              where childuuid = '{nestMeasurementUuid}'";
  q += "                                                                and parentaenttypename = 'Nest'))";
  q += " ";
  q += "     GROUP BY parentuuid";
  q += "     HAVING   aenttimestamp = max(aenttimestamp))";
  q  = replaceFirst(q, "{chickAliveVocabName}", chickAliveVocabName);
  q  = replaceFirst(q, "{nestMeasurementUuid}", nestMeasurementUuid);

  return q;
}
populateWebViewHtml("Nest_Measurement/Nest_Measurement/Spacer", "<br><br>");

//populateWebViewHtml(
  //"Nest/Nest/Click_Button_for_Automated_Date_Insertion_0",
  //"<span style=\"color:6cf\">Click Button for Automated Date Insertion</span>"
//);

populateWebViewHtml(
  "Nest/Nest/Click_Button_for_Automated_Date_Insertion_1",
  "<span style=\"color:6cf\">Click Button for Automated Date Insertion</span>"
);

//populateWebViewHtml(
  //"Nest/Nest/Do_Not_Touch_Until_Relevant",
  //"<span style=\"color:6cf\">Do Not Touch Until Relevant</span>"
//);
onClickNestSetDayofLay () {
  msgHead  = "Proceed To Date Picker?";
  msgBody  = "Have you established the Day of Last Egg? If not, press 'Cancel' and ";
  msgBody += "return. If yes, press 'OK' and select date from date picker. ";
  msgBody += "Once selected, the 'Day of Last Egg' can only be edited but not ";
  msgBody += "blanked.";

  cbOkay   = "goToDayOfLayTabGroup()";
  cbCancel = "";

  showAlert(msgHead, msgBody, cbOkay, cbCancel);
}

goToDayOfLayTabGroup() {
  newTab("Day_of_Lay", true);
}


addOnEvent("Day_of_Lay/Day_of_Lay/Set_Day_of_Lay", "click", "setDayOfLay()");
addOnEvent("Day_of_Lay/Day_of_Lay/Cancel",         "click", "goBack()");

setDayOfLay() {
  src = "Day_of_Lay/Day_of_Lay/Day_of_Lay";
  dst = "Nest/Nest/Day_of_Lay";

  // Change the date picker's DD/MM/YYYY format to YYYY/MM/DD
  val = getFieldValue(src);
  val = val.split("/")[2] + "/" +
        val.split("/")[1] + "/" +
        val.split("/")[0];

  setFieldValue(dst, val);

  goBack();
}
initNestStatus() {
  String parentTabgroup = "Nest";
  String nestUuid       = getUuid(parentTabgroup);
  String refNestStatus  = "Nest_Measurement/Nest_Measurement/Nest_Status";

  String q = "";
  q += " /* Get the Nest Status attribute.";
  q += "  */";
  q += " SELECT vocabId, vocabName";
  q += " FROM   latestnondeletedaentvalue";
  q += " JOIN   attributekey USING (attributeid)";
  q += " JOIN   vocabulary   USING (attributeid, vocabid)";
  q += " WHERE  attributename = 'Nest Status'";
  q += " AND    uuid IN (";
  q += " ";
  q += "     /* Select latest Nest Measurement uuid";
  q += "      */";
  q += "     SELECT    childuuid";
  q += "       FROM    parentchild";
  q += "       JOIN    createdmodifiedatby ON (uuid=childuuid)";
  q += "      WHERE    parentuuid         = '{nestUuid}'";
  q += "        AND    parentaenttypename = 'Nest'";
  q += "        AND    childaenttypename  = 'Nest Measurement'";
  q += "      ORDER BY createdat DESC";
  q += "      LIMIT    1";
  q += " ";
  q += " )";
  q  = replaceFirst(q, "{nestUuid}", nestUuid);

  FetchCallback cb = new FetchCallback() {
    onFetch(result) {
      if      ( result                   == null ) { ; }
      else if ( result.size()            == 0    ) { ; }
      else if ( result.get(1)            == null ) { ; }
      else if (!result.get(1).equals("{75_100_}")) { ; }
      else
        setFieldValue(refNestStatus, result.get(0));
    }
  };

  fetchOne(q, cb);
}
/*************************** BOX STATUS INHERITANCE ***************************/
/* Inheritance is done in rever order (i.e. child to parent instead of parent */
/* to child). The inherited value is not saved in the recipient arch ent. It  */
/* is merely displayed.                                                       */
/*                                                                            */
/* There are two cases to consider when updating the web view:                */
/*   1. A BOX STATUS WAS JUST SAVED -- In this case, the parent's (Box's) web */
/*      view should be updated immediately after the child (Box Status) is    */
/*      saved.                                                                */
/*   2. AN EXISTING BOX WAS JUST LOADED -- The Box's web view should be       */
/*      upated immediately after it was loaded.                               */
/*   3. A NEW BOX WAS CREATED                                                 */
/******************************************************************************/
updateBoxStatusWebView() {
  String tabgroup     = "Box";
  String boxUuid      = getUuid(tabgroup);
  String refBoxStatus = "Box/Box/Box_Status";

  if (isNull(boxUuid)) return;

  String q = "";
  q += " /* Get the Box Status attribute.";
  q += "  */";
  q += " SELECT vocabname";
  q += " FROM   latestnondeletedaentvalue";
  q += " JOIN   attributekey USING (attributeid)";
  q += " JOIN   vocabulary   USING (attributeid, vocabid)";
  q += " WHERE  attributename = 'Box Status'";
  q += " AND    uuid IN (";
  q += " ";
  q += "     /* Select latest Box Status uuid";
  q += "      */";
  q += "     SELECT    childuuid";
  q += "       FROM    parentchild";
  q += "       JOIN    createdmodifiedatby ON (uuid=childuuid)";
  q += "      WHERE    parentuuid         = '{boxUuid}'";
  q += "        AND    parentaenttypename = 'Box'";
  q += "        AND    childaenttypename  = 'Box Status'";
  q += "      ORDER BY createdat DESC";
  q += "      LIMIT    1";
  q += " ";
  q += " )";
  q  = replaceFirst(q, "{boxUuid}", boxUuid);

  FetchCallback populate = new FetchCallback() {
    onFetch(result) {
      if      (result        == null) { ; }
      else if (result.size() == 0   ) { ; }
      else if (result.get(0) == null) { ; }
      else
        setFieldValue(refBoxStatus, result.get(0));
    }
  };

  fetchOne(q, populate);
}

// Overrides autogen's definition
loadBoxFrom(String uuid) {
  String tabgroup = "Box";
  setUuid(tabgroup, uuid);
  if (isNull(uuid)) return;

  FetchCallback updateBoxStatus = new FetchCallback() {
    onFetch(result) {
      populateEntityListsInTabGroup(tabgroup);
      updateBoxStatusWebView();
    }
  };

  showTabGroup(tabgroup, uuid, updateBoxStatus);
}

// Overrides autogen's definition
onShowBoxStatus () {
  saveTabGroup("Box_Status", "updateBoxStatusWebView()");
}
/***************************** ACTIVE BOX SEARCH ******************************/
makeVocab("DropDown", "Control/Active_Boxes/Box_Prefix", "Box Box Prefix");

addOnEvent("Control/Active_Boxes"              , "show"  , "activeBoxSearch()");
addOnEvent("Control/Active_Boxes/Active_Boxes" , "click" , "loadEntity()");
addOnEvent("Control/Active_Boxes/Search"       , "click" , "activeBoxSearch()");

activeBoxSearch() {
  String refBoxPrefix    = "Control/Active_Boxes/Box_Prefix";
  String refBoxId        = "Control/Active_Boxes/Box_ID";
  String refSearchButton = "Control/Active_Boxes/Search";
  String refActiveBoxes  = "Control/Active_Boxes/Active_Boxes";

  String boxPrefix = getFieldValue(refBoxPrefix);
  String boxId     = getFieldValue(refBoxId    );

  String q = "";
  q += " SELECT uuid, response";
  q += "   FROM latestNonDeletedArchEntFormattedIdentifiers";
  q += "  WHERE aenttypename = 'Box'";
  q += "    AND uuid IN (";
  q += "         SELECT parentuuid";
  q += "           FROM latestnondeletedaentvalue";
  q += "           JOIN vocabulary using (vocabid)";
  q += "           JOIN (";
  q += "                 SELECT childuuid, parentuuid";
  q += "                   FROM parentchild";
  q += "                   JOIN latestnondeletedarchent on (childuuid = uuid)";
  q += "                  WHERE childaenttypename = 'Box Status'";
  q += "               GROUP BY parentuuid";
  q += "                 HAVING aenttimestamp = max(aenttimestamp)";
  q += "                ) ON (childuuid = uuid)";
  q += "          WHERE vocabname = '{Active}'";
  q += "        )";
  q += "    AND uuid IN (";
  q += "                 SELECT uuid";
  q += "                   FROM latestnondeletedaentvalue";
  q += "                   JOIN attributekey using (attributeid) ";
  q += "                  WHERE measure LIKE '{boxId}'||'%'";
  q += "                    AND attributename = 'Box Box ID'";
  q += "        )";
  q += "    AND uuid IN (";
  q += "                 SELECT uuid";
  q += "                   FROM latestnondeletedaentvalue";
  q += "                  WHERE vocabid = {boxPrefix}";
  q += "        )";
  q += "  ORDER BY CAST(response AS numeric)";
  q += "  LIMIT ? OFFSET ?";
  q  = replaceFirst(q, "{boxId}",     boxId);
  q  = replaceFirst(q, "{boxPrefix}", boxPrefix);

  populateCursorList(refActiveBoxes, q, 25);
}


/******************************************************************************/
/*                                    INIT                                    */
/*                                                                            */
/* Stuff which needs to be done last.                                         */
/******************************************************************************/
bindOnEvents();
